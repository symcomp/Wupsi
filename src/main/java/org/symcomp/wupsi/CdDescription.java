//---------------------------------------------------------------------------
//  Copyright 2006-2009
//    Dan Roozemond, d.a.roozemond@tue.nl, (TU Eindhoven, Netherlands)
//    Peter Horn, horn@math.uni-kassel.de (University Kassel, Germany)
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//---------------------------------------------------------------------------

package org.symcomp.wupsi;

import java.util.Map;
import java.util.HashMap;

/**
 * contains information about most OM symbold used in the 'describe' command.
 */
public class CdDescription {

    private String cd;
    private String name;
    private String description;
    private String[] examples;

    public String getCd() {
        return cd;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public String[] getExamples() {
        return examples;
    }

    public static CdDescription describe(String thing) {
        return all.get(thing);
    }

    private static Map<String, CdDescription> all = new HashMap<String, CdDescription>();

    public static String[] completions() {
        return all.keySet().toArray(new String[all.size()]);
    }

    private CdDescription(String cd, String name, String description, String[] examples) {
        this.cd = cd;
        this.name = name;
        this.description = description;
        this.examples = examples;
    }

    static void register_omdef(String cd, String name, String description, String[] examples) {
        CdDescription cdd = new CdDescription(cd, name, description, examples);
        if (name != null)
            all.put(cd+"."+name, cdd);
        else
            all.put(cd, cdd);
    }

    static void init() {
        register_omdef("alg1",null,"A CD of basic algebraic concepts At present this CD only holds definitions of zero and one. They are deliberately defined here without specifying any particular structure (e.g. a group) to which they correspond.",new String[] {});
        register_omdef("alg1","zero","This symbol represents the additive identity element.",new String[] {});
        register_omdef("alg1","one","This symbol represents the multiplicative identity element.",new String[] {});
        register_omdef("altenc",null,"A CD of alternative encoding symbols This CD is motivated in part by a desire to maintain compatibility with the MathML semantics element, In order for it to be possible for OpenMath to express symbols in an alternative encoding (this facilitates the exact translation and representation of objects) we use the OpenMath attribution nodes (which performs a similar role to the MathML semantics nodes). The formats and descriptions of common syntaxes are held in this CD; at present this only includes LaTeX and MathML.",new String[] {});
        register_omdef("altenc","MathML_encoding","A symbol which heads a piece of MathML encoding in an attribution. The MathML encoding is an XML encoding, and the details may be found at: http://www.w3.org/Math/Overview.html",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"altenc\" name=\"MathML_encoding\"></OMS> <OMFOREIGN encoding=\"MathML-Presentation\"> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> <mi>sin</mi><mfenced><mn>1.5</mn></mfenced> </math> </OMFOREIGN> <OMS cd=\"altenc\" name=\"LaTeX_encoding\"></OMS> <OMSTR> \\sin(1.5) </OMSTR> </OMATP> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMF dec=\"1.5\"></OMF> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"altenc\" name=\"MathML_encoding\"></OMS> <OMFOREIGN encoding=\"MathML-Presentaion\"> <mrow xmlns=\"http://www.w3.org/1998/Math/MathML\"> <mn mathcolor=\"green\">3</mn> </mrow> </OMFOREIGN> </OMATP> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("altenc","LaTeX_encoding","A symbol which heads a piece of LaTeX encoding in an attribution.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"altenc\" name=\"LaTeX_encoding\"></OMS> <OMSTR> \\sin(1.5) </OMSTR> </OMATP> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMF dec=\"1.5\"></OMF> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("arith1",null,"This CD defines symbols for common arithmetic functions.",new String[] {});
        register_omdef("arith1","lcm","The symbol to represent the n-ary function to return the least common multiple of its arguments.",new String[] {});
        register_omdef("arith1","gcd","The symbol to represent the n-ary function to return the gcd (greatest common divisor) of its arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"gcd\"></OMS> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("arith1","plus","The symbol representing an n-ary commutative function plus.",new String[] {});
        register_omdef("arith1","unary_minus","This symbol denotes unary minus, i.e. the additive inverse.",new String[] {});
        register_omdef("arith1","minus","The symbol representing a binary minus function. This is equivalent to adding the additive inverse.",new String[] {});
        register_omdef("arith1","times","The symbol representing an n-ary multiplication function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 5 </OMI> <OMI> 6 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 7 </OMI> <OMI> 8 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 19 </OMI> <OMI> 22 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 43 </OMI> <OMI> 50 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("arith1","divide","This symbol represents a (binary) division function denoting the first argument right-divided by the second, i.e. divide(a,b)=a*inverse(b). It is the inverse of the multiplication function defined by the symbol times in this CD.",new String[] {});
        register_omdef("arith1","power","This symbol represents a power function. The first argument is raised to the power of the second argument. When the second argument is not an integer, powering is defined in terms of exponentials and logarithms for the complex and real numbers. This operator can represent general powering.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> </OMA> <OMI>3</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 37 </OMI> <OMI> 54 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 81 </OMI> <OMI> 118 </OMI> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMS cd=\"nums1\" name=\"i\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> </OMA> </OMA> <OMA> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMS cd=\"alg1\" name=\"one\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("arith1","abs","A unary operator which represents the absolute value of its argument. The argument should be numerically valued. In the complex case this is often referred to as the modulus.",new String[] {});
        register_omdef("arith1","root","A binary operator which represents its first argument \\\"lowered\\\" to its n\\\'th root where n is the second argument. This is the inverse of the operation represented by the power symbol defined in this CD. Care should be taken as to the precise meaning of this operator, in particular which root is represented, however it is here to represent the general notion of taking n\\\'th roots. As inferred by the signature relevant to this symbol, the function represented by this symbol is the single valued function, the specific root returned is the one indicated by the first CMP. Note also that the converse of the second CMP is not valid in general.",new String[] {});
        register_omdef("arith1","sum","An operator taking two arguments, the first being the range of summation, e.g. an integral interval, the second being the function to be summed. Note that the sum may be over an infinite interval.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"arith1\" name=\"sum\"></OMS> <OMA> <OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMI> 1 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("arith1","product","An operator taking two arguments, the first being the range of multiplication e.g. an integral interval, the second being the function to be multiplied. Note that the product may be over an infinite interval.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"integer1\" name=\"factorial\"></OMS> <OMV name=\"n\"></OMV> </OMA> <OMA> <OMS cd=\"arith1\" name=\"product\"></OMS> <OMA> <OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMV name=\"n\"></OMV> </OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"i\"></OMV> </OMBVAR> <OMV name=\"i\"></OMV> </OMBIND> </OMA> </OMA> </OMOBJ>"});
        register_omdef("arith2",null,"Further to the basic arithmetic functions, we define some more common arithmetic operations. This includes a commutative times which exhibits the use of inheritance within the CD\\\'s.",new String[] {});
        register_omdef("arith2","times","The symbol representing an n-ary multiplication function inheriting from the times in arith1, but with the extra property that here it must be commutative.",new String[] {});
        register_omdef("arith2","inverse","A unary operator which represents the inverse of an element of a set. This symbol could be used to represent additive or multiplicative inverses.",new String[] {});
        register_omdef("arith3",null,"Extended GCD",new String[] {});
        register_omdef("arith3","extended_gcd","The symbol represents the n-ary function, a_1,...,a_n to return a list consisting of the gcd (greatest common divisor) of its arguments, together with n elements x_1,...,x_n such that gcd(a_1,...,a_n)=x_1 a_1+...+x_n a_n",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"arith3\" name=\"extended_gcd\"></OMS> <OMA><OMS cd=\"arith3\" name=\"extended_gcd\"></OMS> <OMI> 6 </OMI> <OMI> 10 </OMI> <OMI> 15 </OMI> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>1</OMI> <OMI>1</OMI> <OMI>-2</OMI> <OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("bigfloat1",null,"This CD provides a common representation of \\\"bigfloats\\\" in a mantissa/ radix/exponent format. There is a further version, which provides an opportunity to state a precision (only required in a different radix). No operations are defined here -- see arith and alg.",new String[] {});
        register_omdef("bigfloat1","bigfloat","The bigfloat constructor takes three arguments, a mantissa, a base and the exponent.",new String[] {});
        register_omdef("bigfloat1","bigfloatprec","The bigfloat \\\"with precision specified in (another) radix\\\" constructor. Takes 3 arguments, the first argument is a floating point number constructed with the bigfloat constructor, the second is the new radix, whilst the third specifies how many digits are significant.",new String[] {});
        register_omdef("calculus1",null,"This CD is intended to be compatible with the calculus operations in Content MathML. Integration is just for the univariate case and is either definite or indefinite.",new String[] {});
        register_omdef("calculus1","diff","This symbol is used to express ordinary differentiation of a unary function. The single argument is the unary function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMA> <OMS cd=\"calculus1\" name=\"diff\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMF dec=\"1.0\"></OMF> </OMA> </OMBIND> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMF dec=\"1.0\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("calculus1","nthdiff","This symbol is used to express the nth-iterated ordinary differentiation of a unary function. The first argument is n, and the second the unary function.",new String[] {});
        register_omdef("calculus1","partialdiff","This symbol is used to express partial differentiation of a function of more than one variable. It has two arguments, the first is a list of integers which index the variables of the function, the second is the function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMA> <OMS cd=\"calculus1\" name=\"partialdiff\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 3 </OMI> </OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> <OMV name=\"z\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> <OMV name=\"z\"></OMV> </OMA> </OMBIND> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMV name=\"y\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("calculus1","int","This symbol is used to represent indefinite integration of unary functions. The argument is the unary function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"calculus1\" name=\"int\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"cos\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("calculus1","defint","This symbol is used to represent definite integration of unary functions. It takes two arguments; the first being the range (e.g. a set) of integration, and the second the function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"calculus1\" name=\"defint\"></OMS> <OMA> <OMS cd=\"interval1\" name=\"interval\"></OMS> <OMF dec=\"-1.0\"></OMF> <OMF dec=\"1.0\"></OMF> </OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"calculus1\" name=\"defint\"></OMS> <OMV name=\"C\"></OMV> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMV name=\"f\"></OMV> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("cc",null,"CC Type Attribution for OM Initial version: O. Caprotti (May 20, 1999) Revised: O. Caprotti (Aug 20, 1999), split-up so that it uses symbols from lc, omtypes.",new String[] {});
        register_omdef("cc","type","Attribution tag to denote type-judgement",new String[] {});
        register_omdef("cc","typecoerce","Attribution tag to denote type-judgement with coercion",new String[] {});
        register_omdef("coercions",null,"Coercion Functions among OM Types Initial version: O. Caprotti",new String[] {});
        register_omdef("coercions","int2flt","The function that converts an integer to a float.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR><OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"omtypes\" name=\"float\"></OMS> </OMATP> <OMA> <OMS cd=\"coercions\" name=\"int2flt\"></OMS> <OMI> 1 </OMI> </OMA> </OMATTR></OMOBJ>"});
        register_omdef("combinat1",null,"This CD defines some basic combinatorics definitions.",new String[] {});
        register_omdef("combinat1","binomial","The binomial coefficients. binomial(n, m) is the number of ways of choosing m objects from a collection of n distinct objects without regard to the order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"binomial\"></OMS> <OMI> 4 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 6 </OMI> </OMA> </OMOBJ>"});
        register_omdef("combinat1","multinomial","The multinomial coefficient, multinomial(n, n1, ... nk) is the number of ways of choosing ni objects of type i (i from 1 to k) without regard to order, in such a way that the total number of objects chosen is n. multinomial(n, n1, ... nk) is equal to n!/(n1!*n2! ...*nk!).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"multinomial\"></OMS> <OMI> 8 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 3 </OMI> </OMA> <OMI> 560 </OMI> </OMA> </OMOBJ>"});
        register_omdef("combinat1","Stirling1","The Stirling numbers of the first kind. (-1)^(n-m)*Stirling1(n,m) is the number of permutations of n symbols which have exactly m cycles. Note that there are a few slightly different definitions of these numbers.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"Stirling1\"></OMS> <OMI> 10 </OMI> <OMI> 7 </OMI> </OMA> <OMI> -9450 </OMI> </OMA> </OMOBJ>"});
        register_omdef("combinat1","Stirling2","The Stirling numbers of the second kind. Stirling2(n, m) is the number of partitions of a set with n elements into m non empty subsets. Note that there are a few slightly different definitions of these numbers.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"Stirling2\"></OMS> <OMI> 7 </OMI> <OMI> 3 </OMI> </OMA> <OMI> 301 </OMI> </OMA> </OMOBJ>"});
        register_omdef("combinat1","Fibonacci","The Fibonacci numbers, defined by the linear recurrence: Fibonacci(0) = 0, Fibonacci(1) = 1, and Fibonacci(n + 1) = Fibonacci(n) + Fibonacci(n - 1). Note that some authors define Fibonacci(0) = 1.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"Fibonacci\"></OMS> <OMI> 10 </OMI> </OMA> <OMI> 55 </OMI> </OMA> </OMOBJ>"});
        register_omdef("combinat1","Bell","The Bell numbers: Bell(n) is the total number of possible partitions of a set of n elements.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"combinat1\" name=\"Bell\"></OMS> <OMI> 7 </OMI> </OMA> <OMI> 877 </OMI> </OMA> </OMOBJ>"});
        register_omdef("complex1",null,"This CD is intended to be `compatible\\\' with the MathML view of operations on and constructors for complex numbers.",new String[] {});
        register_omdef("complex1","complex_cartesian","This symbol represents a constructor function for complex numbers specified as the Cartesian coordinates of the relevant point on the complex plane. It takes two arguments, the first is a number x to denote the real part and the second a number y to denote the imaginary part of the complex number x + i y. (Where i is the square root of -1.)",new String[] {});
        register_omdef("complex1","real","This represents the real part of a complex number",new String[] {});
        register_omdef("complex1","imaginary","This represents the imaginary part of a complex number",new String[] {});
        register_omdef("complex1","complex_polar","This symbol represents a constructor function for complex numbers specified as the polar coordinates of the relevant point on the complex plane. It takes two arguments, the first is a nonnegative number r to denote the magnitude and the second a number theta (given in radians) to denote the argument of the complex number r e^(i theta). (i and e are defined as in this CD).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMS cd=\"nums1\" name=\"i\"></OMS> <OMA> <OMS cd=\"complex1\" name=\"complex_polar\"></OMS> <OMS cd=\"alg1\" name=\"one\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMI> 2 </OMI> </OMA> </OMA> </OMA></OMOBJ>"});
        register_omdef("complex1","argument","This symbol represents the unary function which returns the argument of a complex number, viz. the angle which a straight line drawn from the number to zero makes with the Real line (measured anti-clockwise). The argument to the symbol is the complex number whos argument is being taken.",new String[] {});
        register_omdef("complex1","conjugate","A unary operator representing the complex conjugate of its argument.",new String[] {});
        register_omdef("dimensions1",null,"This CD defines symbols which represent basic physical dimensions.",new String[] {});
        register_omdef("dimensions1","length","This symbol represents the length physical dimension.",new String[] {});
        register_omdef("dimensions1","area","This symbol represents the area physical dimension.",new String[] {});
        register_omdef("dimensions1","volume","This symbol represents the volume physical dimension.",new String[] {});
        register_omdef("dimensions1","speed","This symbol represents the speed physical dimension. It is the size of the derivative of distance with respect to time.",new String[] {});
        register_omdef("dimensions1","displacement","This symbol represents the spatial difference between two points. The direction of the displacement is taken into account as well as the distance between the points.",new String[] {});
        register_omdef("dimensions1","velocity","This symbol represents the velocity physical dimension. It is the derivative of distance with respect to time.",new String[] {});
        register_omdef("dimensions1","acceleration","This symbol represents the acceleration physical dimension. It is the second derivative of distance with respect to time.",new String[] {});
        register_omdef("dimensions1","time","This symbol represents the time physical dimension.",new String[] {});
        register_omdef("dimensions1","mass","This symbol represents the mass physical dimension.",new String[] {});
        register_omdef("dimensions1","force","This symbol represents the force physical dimension.",new String[] {});
        register_omdef("dimensions1","temperature","This symbol represents the temperature physical dimension.",new String[] {});
        register_omdef("dimensions1","pressure","This symbol represents the pressure physical dimension.",new String[] {});
        register_omdef("dimensions1","charge","This symbol represents the charge physical dimension.",new String[] {});
        register_omdef("dimensions1","current","This symbol represents the current physical dimension.",new String[] {});
        register_omdef("dimensions1","voltage","This symbol represents the voltage physical dimension.",new String[] {});
        register_omdef("dimensions1","resistance","This symbol represents the resistance physical dimension, it is the resistance that an electrical circuit has to flow of charge.",new String[] {});
        register_omdef("dimensions1","density","This symbol represents the density physical dimension, it is the mass per unit volume.",new String[] {});
        register_omdef("dimensions1","energy","This symbol represents the energy physical dimension.",new String[] {});
        register_omdef("dimensions1","concentration","This symbol represents the concentration physical dimension, it is the amount of a substance in a volume.",new String[] {});
        register_omdef("dimensions1","momentum","This symbol represents the momentum physical dimension, it is mass times velocity.",new String[] {});
        register_omdef("directives1",null,"The primal objective of OpenMath objects is to represent mathematical expressions. In this Content Dictionary another objective is addressed, namely to express an action related to a mathematical expression. Such a request for an action is generally referred to as a query. The specific queries are called directives. In this CD we define some. An entity (software) carrying out the query is referred to as a service. The service might return an OpenMath object. To formalize this object, we also introduce the symbol response in this CD. amc 2004-03-18: added the directive explore. amc 2004-03-24: removed redundancies.",new String[] {});
        register_omdef("directives1","evaluate","This symbol is a function with one argument, which should be a mathematical expression. When applied to a mathematical expression, it asks for an evaluation or simplification of the expression. The evaluation or simplification to be carried out by a service is a simpler mathematical expression (in some definition of complexity of objects) which is equal to the argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"directives1\" name=\"evaluate\"></OMS> <OMA><OMS cd=\"transc1\" name=\"sin\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("directives1","evaluate_to_type","This symbol is a function with two arguments, which should be a mathematical expression and a type. When applied to a mathematical expression E and a type T, it asks for an evaluation or simplification of E to a mathematical expression of type T.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"directives1\" name=\"evaluate\"></OMS> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>7</OMI><OMI>6</OMI> </OMA> <OMI>2</OMI> </OMA> <OMS cd=\"setname1\" name=\"N\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("directives1","look_up","This symbol is a function with one argument, which should be a mathematical expression. When applied to a mathematical expression, it asks for mathematical expressions related to the argument. If the argument is a single OpenMath symbol, the service might respond by the list of all properties in the CD containing the argument. Alternatively, the service can provide a list of CDs which use the CD in which the argument occurs. Another service might return all documents in which the symbol occurs. If the argument is a more complicated object, the same services could be called for, but then with all OpenMath symbols occurring in the argument instead of the single one.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"directives1\" name=\"look_up\"></OMS> <OMS cd=\"transc1\" name=\"sin\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("directives1","response","This symbol is a function of one argument, which should be a query. When applied to a query, it refers to the response a service might give. It will mainly be used in this CD to express formal mathematical properties of queries.",new String[] {});
        register_omdef("directives1","prove","This symbol is a function with one argument, which should be a clause. When applied to a clause C, it asks for a proof of C.",new String[] {});
        register_omdef("directives1","disprove","This symbol is a function with one argument, which should be a clause. When applied to a clause C, it asks for a proof of that C does not hold.",new String[] {});
        register_omdef("directives1","prove_in_theory","This symbol is a function with two arguments, the first of which should be a clause and the second of which should be a symbol indicating a logic theory. When applied to arguments C, T, it asks for a proof of C in theory T.",new String[] {});
        register_omdef("directives1","find","This symbol is a binder, whose body should be a clause. When bound to a variable (or list of variables) x with body P(x), it asks for a mathematical expression A such that P(A) holds.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMBIND><OMS cd=\"directives1\" name=\"find\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"logic1\" name=\"and\"></OMS> <OMA><OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"x\"></OMV><OMS cd=\"setname1\" name=\"R\"></OMS> </OMA> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"transc1\" name=\"sin\"></OMS><OMV name=\"x\"></OMV></OMA> <OMI>0</OMI> </OMA> </OMA> </OMBIND> </OMOBJ>"});
        register_omdef("directives1","decide","This symbol is a function with one argument, which should be a clause. When applied to a clause, it asks whether the clause holds.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"directives1\" name=\"decide\"></OMS> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"transc1\" name=\"sin\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> </OMA> <OMI>0</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("directives1","explore","This symbol is a unary function whose argument should be a mathematical assertion. When applied to an assertion A, it asks for conditions under which the assertion holds.",new String[] {});
        register_omdef("ecc",null,"Extended Calculus of Constructions Primitives Initial version: O. Caprotti (July 1, 1999) Revised: O. Caprotti (September 8, 1999)",new String[] {});
        register_omdef("ecc","type","Attribution tag to denote type-judgement",new String[] {});
        register_omdef("ecc","typecoerce","Attribution tag to denote type-judgement with coercion",new String[] {});
        register_omdef("ecc","SigmaType","The binder symbol used to construct the type of Cartesian products. The (either plain or attributed) variables might occur in the body \\\\OM\\\\ object.",new String[] {});
        register_omdef("ecc","Pair","The pairing constructor. It takes two OpenMath objects as first element and second element of the pair, and a third optional OpenMath object that represents the type of the pair.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"ecc\" name=\"Pair\"></OMS> <OMI>0</OMI> <OMI>1</OMI> </OMA> </OMOBJ>"});
        register_omdef("ecc","PairProj1","The first projection function that extracts the first component of a Pair. It satisfies the sigma-reduction rule.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ecc\" name=\"PairProj1\"></OMS> <OMA><OMS cd=\"ecc\" name=\"Pair\"></OMS> <OMI>0</OMI> <OMI>1</OMI> </OMA> </OMA> <OMI>0</OMI> </OMA> </OMOBJ>"});
        register_omdef("ecc","PairProj2","The second projection function that extracts the second component of a Pair. It satisfies sigma-reduction rule.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ecc\" name=\"PairProj2\"></OMS> <OMA><OMS cd=\"ecc\" name=\"Pair\"></OMS> <OMI>0</OMI> <OMI>1</OMI> </OMA> </OMA> <OMI>1</OMI> </OMA> </OMOBJ>"});
        register_omdef("ecc","Tuple","The n-ary tupling constructor when n>2. The arguments are the element of the tuple. Tuple objects can also be constructed by successive nesting of Pair.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ecc\" name=\"Pair\"></OMS> <OMI>0</OMI> <OMA><OMS cd=\"ecc\" name=\"Pair\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMA> <OMA><OMS cd=\"ecc\" name=\"Tuple\"></OMS> <OMI>0</OMI> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("error",null,"This symbol represents the error which is raised when an application reads a symbol which is present in the mentioned content dictionary, but which it has not implemented. When receiving such a symbol, the application should act as if it had received the OpenMath error object constructed from unhandled_symbol and the unhandled symbol as in the example below.",new String[] {});
        register_omdef("error","unhandled_symbol","This symbol represents the error which is raised when an application reads a symbol which is present in the mentioned content dictionary, but which it has not implemented. When receiving such a symbol, the application should act as if it had received the OpenMath error object constructed from unhandled_symbol and the unhandled symbol as in the example below.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"error\" name=\"unhandled_symbol\"></OMS> <OMS cd=\"setname1\" name=\"C\"></OMS> </OME> </OMOBJ>"});
        register_omdef("error","unexpected_symbol","This symbol represents the error which is raised when an application reads a symbol which is not present in the mentioned content dictionary. When receiving such a symbol, the application should act as if it had received the OpenMath error object constructed from unexpected_symbol and the unexpected symbol as in the example below.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"error\" name=\"unexpected_symbol\"></OMS> <OMS cd=\"arith1\" name=\"plurse\"></OMS> </OME> </OMOBJ>"});
        register_omdef("error","unsupported_CD","This symbol represents the error which is raised when an application reads a symbol where the mentioned content dictionary is not present. When receiving such a symbol, the application should act as if it had received the OpenMath error object constructed from unsupported_CD and the symbol from the unsupported Content Dictionary as in the example below.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"error\" name=\"unsupported_CD\"></OMS> <OMS cd=\"specfun1\" name=\"BesselJ\"></OMS> </OME> </OMOBJ>"});
        register_omdef("field1",null,"A CD of basic functions for field theory",new String[] {});
        register_omdef("field1","field","This symbol is a constructor for fields. It takes seven arguments R, a, o, n, m, e, i: which are, respectively, a set R to specify the elements in the field, a binary operation a on R, an element o of R, and a unary operation n on R such that [R,a,o,n] is a commutative group, a binary operation m on R, an element e of R, and a map from R - {o} to itself such that [R,m,e] is a monoid and such that [R - {o},m\\\',e,i] is a group, where m\\\' is the restriction of m to R -{o}.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMI> 1 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("field1","carrier","This symbol represents a unary function, whose argument should be a field S (for instance constructed by field). When applied to S, its value should be the set of elements of S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"R\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","multiplication","This symbol represents a unary function, whose argument should be a field S. It returns the multiplication map on the field. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","minus","This symbol represents a unary function, whose argument should be a field S. It returns the map sending an element of S to its additive inverse.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"minus\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"minus\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","inverse","This symbol represents a unary function, whose argument should be a field S. It returns the map sending a nonzero element of S to its multiplicative inverse.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"inverse\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"inv\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","identity","This symbols represents a unary function, whose argument should be a field. It returns the identity element of the field.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"identity\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"one\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","zero","This symbols represents a unary function, whose argument should be a field. It returns the zero element of the field.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"zero\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"zero\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","addition","This symbols represents a unary function, whose argument should be a field. It returns the addition map on the field. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"identity\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMV name=\"plus\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field1","subtraction","This symbols represents a unary function, whose argument should be a field. It returns the binary operation of subtraction on the field.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"subtraction\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV><OMV name=\"y\"></OMV> </OMBVAR> <OMA><OMV name=\"plus\"></OMV> <OMV name=\"x\"></OMV> <OMA><OMV name=\"minus\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("field1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative field.",new String[] {});
        register_omdef("field1","is_subfield","The binary boolean function whose value is true iff the second argument is a subfield of the second.",new String[] {});
        register_omdef("field1","additive_group","This symbol is a unary function, whose argument should be a field S. When applied to S its value is the monoid underlying S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"additive_group\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field1","multiplicative_group","This symbol is a unary function, whose argument should be a field S. When applied to S its value is the multiplicative group on the nonzero elements of S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"multiplicative_group\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> <OMV name=\"inv\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field1","subfield","This symbol is a constructor symbol with one or two arguments. The first argument is a list or set, D, of field elements. The optional second argument is the field G containing D. It denotes the subfield of G generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field1\" name=\"subfield\"></OMS> <OMV name=\"D\"></OMV> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field1\" name=\"subfield\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"relation1\" name=\"neq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMS cd=\"arith2\" name=\"inverse\"></OMS> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field1","power","This is a symbol with two or three arguments. Its first argument should be an element g of a field and the second argument should be an integer. The optional third argument is the field G containing g. It denotes the element g^k in G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"field1\" name=\"power\"></OMS> <OMI>3</OMI> <OMI>2</OMI> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMI> 1 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMA> <OMI>9</OMI> </OMA> </OMOBJ>"});
        register_omdef("field1","expression","This symbol is a function with two arguments. Its first argument should be a field. The second should be an arithmetic expression A, whose operators are times, plus, minus, unary_minus, and power, and whose leaves are members of the carrier of G. When applied to G and A, it denotes the element (of G) that is the element obtained from the leaves of A by applying the operations of G instead of those from the CD arith1 according to A. Here multiplication, addition, subtraction, minus, and power take over the roles of times, plus, minus, unary_minus, and power, respectively. Also, an integer m occurring in A will be interpreted as a member of G by interpreting it as the sum of m copies of the identity element, the symbol alg1.one will be interpreted as the identity, and the symbol alg1.zero will be interpreted as the zero of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"expression\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>6</OMI><OMI>3</OMI> </OMA> </OMA> <OMI>18</OMI> </OMA> </OMOBJ>"});
        register_omdef("field2",null,"Basic functions for homomorphisms in field theory",new String[] {});
        register_omdef("field2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are fields M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a field homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are fields M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a field isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a field M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a field endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field2","is_automorphism","This symbol is a boolean function with two arguments. The first is a field M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a field automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field2","left_multiplication","This symbol is a function with two arguments, which should be a field M and an element x of M. When applied to M and x, it denotes left multiplication on M by x.",new String[] {});
        register_omdef("field2","right_multiplication","This symbol is a function with two arguments, which should be a field M and an element x of M. When applied to M and x, it denotes right multiplication on M by x.",new String[] {});
        register_omdef("field2","conjugation","This symbol is a function with two arguments, which should be a field M and a nonzero element x of M. When applied to M and x, it denotes conjugation on M by x.",new String[] {});
        register_omdef("field2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are fields. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("field3",null,"A CD of functions for basic constructions in field theory.",new String[] {});
        register_omdef("field3","free_field","This symbol represents a binary function. The first argument should be a natural number p which is zero or a prime number, the second argument a list or a set L. When evaluated on such arguments p and L, the function represents the field of rational functions in L over the rationals if p = 0 and over the field of integers mod p if p is a prime.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field3\" name=\"free_field\"></OMS> <OMI>0</OMI> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field3","fraction_field","This is a unary function. Its argument should be a domain (as in CD ring4). It denotes the fraction field of the domain.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMA> <OMS cd=\"field3\" name=\"fraction_field\"></OMS> <OMS cd=\"ringname1\" name=\"Z\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field3","field_by_poly","This symbol is a binary function whose first argument is a univariate polynomial ring R over a field, and whose second argument is an irreducible polynomial f in this polynomial ring R. So, when applied to R and f, the function has value the quotient ring R/(f).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMA><OMS cd=\"field3\" name=\"field_by_poly\"></OMS> <OMA id=\"pr\"><OMS cd=\"polyd1\" name=\"poly_ring_d_named\"></OMS> <OMA><OMS cd=\"setname2\" name=\"GFp\"></OMS> <OMI>2</OMI> </OMA> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMR href=\"#pr\"></OMR> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>0</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field4",null,"A CD of functions for morphisms of fields.",new String[] {});
        register_omdef("field4","automorphism_group","This is a function with a single argument which must be a field. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("field4","homomorphism_by_generators","This is a function with three arguments the first two of which must be fields F and K. The third argument should be a set or a list L of ordered pairs (lists of length 2). Each pair [x,y] from L consists of an element x from F and an element y from K. when applied to F, K, and L, the symbol represents the homomorphism from F to K that maps the first entry x of each pair [x,y] to the second entry y of the same pair.",new String[] {});
        register_omdef("field4","field_by_poly_map","Same as quotient_by_poly_map in CD ring5, except that R and the quotient ring R[X]/(f) are fields (so f is irreducible in R[X]).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMA><OMS cd=\"field4\" name=\"field_by_poly_map\"></OMS> <OMA id=\"pr\"><OMS cd=\"polyd1\" name=\"poly_ring_d\"></OMS> <OMA><OMS cd=\"setname2\" name=\"GFp\"></OMS> <OMI>3</OMI> </OMA> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMR href=\"#pr\"></OMR> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>0</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMR href=\"#pr\"></OMR> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMV name=\"b\"></OMV><OMI>0</OMI> </OMA> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMV name=\"a\"></OMV><OMI>1</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("field4","field_by_poly_vector","This symbol is a binary function. Its first argument should be a field_by_poly(R,f). Its second argument should be a list L of elements of F, the coefficient field of the univariate polynomial ring R = F[X]. The length of the list L should be equal to the degree d of f. When applied to R and L, it represents the element L[0] + L[1] x + L[2] x^2 + ... + L[d-1] ^(d-1) of R/(f), where x stands for the image of x under the natural quotient map R -> R/(f). If the first argument is a field_by_conway(p,n), defined in the CD finfield1, then the same interpretation holds, where R and f are respectively poly_ring_d(GFp(p),1) and conway_polynomial(p,n).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"field4\" name=\"field_by_poly_vector\"></OMS> <OMA><OMS cd=\"finfield1\" name=\"field_by_conway\"></OMS> <OMA><OMS cd=\"setname2\" name=\"GFpn\"></OMS> <OMI>2</OMI><OMI>2</OMI> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>1</OMI> <OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("fieldname1",null,"A CD of functions for basic constructions in field theory.",new String[] {});
        register_omdef("fieldname1","C","This is a symbol representing the field of complex numbers.",new String[] {});
        register_omdef("fieldname1","R","This is a symbol representing the field of real numbers.",new String[] {});
        register_omdef("fieldname1","Q","This is a symbol representing the field of rational numbers.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMA><OMS cd=\"field1\" name=\"field\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMI> 1 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMA> </OMOBJ>"});
        register_omdef("finfield1",null,"A CD to instantiate finite fields.",new String[] {});
        register_omdef("finfield1","is_primitive","This symbol represents a binary Boolean function. The first argument should be a finite field, the second a an element of that field. When applied to such arguments, the value represented is true if the second argument is a primitive element of the field, that is, a generator of the multiplicative group of the field.",new String[] {});
        register_omdef("finfield1","field_by_conway","This symbol represents a binary function. The first argument should be a prime number p, the second argument a positive integer n. This symbol returns the field GF(q)[X]/ (C(X)), where q = p^n, X is an indeterminate, C(X) is the Conway polynomial f_{n,p}(X), and (C(X)) is the ideal in the polynomial ring GF(q)[X] generated by C(X).",new String[] {});
        register_omdef("finfield1","primitive_element","This symbol has one or two arguments. If there is only one argument, it must be a prime power q. The optional second argument is a polynomial m which is primitive over the prime subfield of GF(q). This symbol returns a primitive element for GF(q) with minimal polynomial m. If there is only one argument, then the minimal polynomial is assumed to be the conway polynomial for GF(q).",new String[] {});
        register_omdef("finfield1","is_primitive_poly","This symbol is a Boolean-valued function with two arguments, the first of which should be a prime number p, and the second of which should be a polynomial with coefficients in GF(p). When applied to p and f, this symbol represents the value true if and only if f is a primitive polynomial, that is, f is irreducible over GF(p), so GF(p)[X]/(f) is a finite field of order p^n, where n is the degree of f, and the image of X in GF(p)[X]/(f) is a generator of the (cyclic) multiplicative group of GF(p)[X]/(f).",new String[] {});
        register_omdef("finfield1","conway_polynomial","This symbol represents a binary function. Its arguments should be a prime number p and a positive integer n. Before defining which of the possible f(X) is the Conway polynomial we introduce an ordering of the (univariate) polynomials of degree n over GF(p). Here the coefficients of the polynomials are taken in {0, ..., p-1}, the indeterminate is X. Let g(X) = g_nX^n + ... + g_0 and h(X) = h_nX^n + ... + h_0. Then we define g < h if and only if there is an index k with g_i = h_i for i > k and (-1)^{n-k} g_k < (-1)^{n-k} h_k. The Conway polynomial f_{p,n}(X) for GF(p^n) is defined recursively as the smallest polynomial of degree n with respect to this ordering such that: 1) f_{p,n}(X) is monic, 2) f_{p,n}(X) is primitive, that is, it is irreducible and its zeros are generators of the (cyclic) multiplicative group of GF(p^n), 3) for each proper divisor m of n we have that f_{p,m}(X^{(p^n-1) / (p^m-1)})= 0 mod f_{p,n}(X); that is, the ((p^n-1) / (p^m-1))-th power of a zero of f_{p,n}(X) is a zero of f_{p,m}(X).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"finfield1\" name=\"conway_polynomial\"></OMS> <OMI>2</OMI><OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"poly_ring_d\"></OMS> <OMA><OMS cd=\"setname2\" name=\"GFp\"></OMS> <OMI>2</OMI> </OMA> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>0</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>1</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("finfield1","field_by_conway","This symbol has two arguments. Its first argument should be a prime number p and its second argument a positive integer n. When applied to p and n, the result is the field defined as the quotient ring GF(p)[X]/(c(X)), where c(X)=conway_polynomial(p,n).",new String[] {});
        register_omdef("finfield1","minimal_polynomial","This symbol represents a function with one or two arguments. Its first argument should be an element x of a finite field F. The second argument should be a subfield K of F. It returns the minimal polynomial of x over K. If there is only one argument, K defaults to the prime subfield of F.",new String[] {});
        register_omdef("finfield1","discrete_log","This symbol represents a binary function. The first argument is the base b, a primitive element of a finite field F. The second argument is a nonzero element x in F. It returns the smallest nonnegative integer i such that x=b^i.",new String[] {});
        register_omdef("fns1",null,"This CD is intended to be `compatible\\\' with the corresponding elements in Content MathML. In this CD we give a set of functions concerning functions themselves. Functions can be constructed from expressions via a lambda expression. Also there are basic function functions like compose, etc.",new String[] {});
        register_omdef("fns1","domainofapplication","The domainofapplication element denotes the domain over which a given function is being applied. It is intended in MathML to be a more general alternative to specification of this domain using such quantifier elements as bvar, lowlimit or condition.",new String[] {});
        register_omdef("fns1","domain","This symbol denotes the domain of a given function, which is the set of values it is defined over.",new String[] {});
        register_omdef("fns1","range","This symbol denotes the range of a function, that is a set that the function will map to. The single argument should be the function whos range is being queried. It should be noted that this is not necessarily equal to the image, it is merely required to contain the image.",new String[] {});
        register_omdef("fns1","image","This symbol denotes the image of a given function, which is the set of values the domain of the given function maps to.",new String[] {});
        register_omdef("fns1","identity","The identity function, it takes one argument and returns the same value.",new String[] {});
        register_omdef("fns1","left_inverse","This symbol is used to describe the left inverse of its argument (a function). This inverse may only be partially defined because the function may not have been surjective. If the function is not surjective the left inverse function is ill-defined without further stipulations. No other assumptions are made on the semantics of this left inverse.",new String[] {});
        register_omdef("fns1","right_inverse","This symbol is used to describe the right inverse of its argument (a function). This inverse may only be partially defined because the function may not have been surjective. If the function is not surjective the right inverse function is ill-defined without further stipulations. No other assumptions are made on the semantics of this right inverse.",new String[] {});
        register_omdef("fns1","inverse","This symbol is used to describe the inverse of its argument (a function). This inverse may only be partially defined because the function may not have been surjective. If the function is not surjective the inverse function is ill-defined without further stipulations. No assumptions are made on the semantics of this inverse.",new String[] {});
        register_omdef("fns1","left_compose","This symbol represents the function which forms the left-composition of its two (function) arguments.",new String[] {});
        register_omdef("fns1","lambda","This symbol is used to represent anonymous functions as lambda expansions. It is used in a binder that takes two further arguments, the first of which is a list of variables, and the second of which is an expression, and it forms the function which is the lambda extraction of the expression",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMBIND> <OMS cd=\"quant1\" name=\"forall\"></OMS> <OMBVAR> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMBVAR> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMBVAR> <OMV name=\"f\"></OMV> </OMBIND> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> <OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"y\"></OMV> </OMBVAR> <OMV name=\"f\"></OMV> </OMBIND> <OMV name=\"b\"></OMV> </OMA> </OMBIND> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMBIND> </OMOBJ>"});
        register_omdef("fns2",null,"This CD holds further functions concerning functions themselves. A particularly interesting function is apply_to_list which applies an nary function to all the elements in a specified list. For example, such a function can be used to form sums and products in conjunction with plus and times respectively.",new String[] {});
        register_omdef("fns2","kernel","This symbol denotes the kernel of a given function. This may be defined as the subset of the range of the given function which maps to the identity element of the image of the given function, however no semantics are assumed. The kernel of a function is also known as the null space of the function.",new String[] {});
        register_omdef("fns2","apply_to_list","This symbol is used to denote the repeated application of an n-ary function on the elements of a given list. For example when used with plus or times this can represent sums and products. The symbol takes two arguments; the first of which is the n-ary function, the second a list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMBIND> <OMS cd=\"quant1\" name=\"forall\"></OMS> <OMBVAR> <OMV name=\"n\"></OMV> </OMBVAR> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"fns2\" name=\"apply_to_list\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"list1\" name=\"make_list\"></OMS> <OMI> 1 </OMI> <OMV name=\"n\"></OMV> <OMS cd=\"fns1\" name=\"identity\"></OMS> </OMA> </OMA> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMI> 1 </OMI> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMA> </OMBIND> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"fns2\" name=\"apply_to_list\"></OMS> <OMS cd=\"set1\" name=\"set\"></OMS> <OMA> <OMS cd=\"list1\" name=\"make_list\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMBIND> </OMA> </OMA> </OMOBJ>"});
        register_omdef("fns2","right_compose","This symbol represents a function forming the right-composition of its two functional arguments.",new String[] {});
        register_omdef("fns3",null,"This CD holds further functions concerning functions themselves. A particularly interesting function is function which constructs a function with given domain and range.",new String[] {});
        register_omdef("fns3","function","This symbol denotes a function constructor. When aplied to at least two arguments, which are sets, the first argument is the domain and the second the range of the function. When applied to at least three arguments, the first two of which are stes and the third of which is a lambda expression, the third argument gives the function specification.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"fns3\" name=\"function\"></OMS> <OMS cd=\"setname1\" name=\"N\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"n\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMI> 1 </OMI> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("fns3","specification","This symbol denotes the specification of a function. It is a unary function. When aplied to its argument, which should be a function applied to three arguments, it returns the third argument of the function, that is, the function specification.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"fns3\" name=\"specification\"></OMS> <OMA><OMS cd=\"fns3\" name=\"function\"></OMS> <OMS cd=\"setname1\" name=\"N\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"n\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMI> 1 </OMI> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMBIND> </OMA> </OMA> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"n\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMI> 1 </OMI> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("graph1",null,"This CD defines symbols for handling directed and undirected graphs. Authored by Hans Cuypers and Erik Postma. This version is edited by amc.",new String[] {});
        register_omdef("graph1","graph","This symbol represents an undirected graph. It takes two arguments: the vertex set of the graph and the edge set. The vertices can be arbitrary OpenMath objects. Each edge should be a set consisting of two vertices.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"graph1\" name=\"graph\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("graph1","vertexset","This symbol represents the vertex set of a (directed or undirected) graph. It takes one argument, the graph.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"v\"></OMV> </OMBVAR> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"v\"></OMV> <OMA> <OMS cd=\"graph1\" name=\"vertexset\"></OMS> <OMV name=\"Gamma\"></OMV> </OMA> </OMA> </OMBIND> </OMOBJ>"});
        register_omdef("graph1","edgeset","This symbol represents the set of edges of an undirected graph. It takes one argument, the undirected graph.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMV name=\"v\"></OMV> <OMV name=\"w\"></OMV> </OMA> <OMA> <OMS cd=\"graph1\" name=\"edgeset\"></OMS> <OMV name=\"Gamma\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("graph1","digraph","This symbol refers to a digraph. It has two arguments. The first is the set of vertices, the second is the set of arrows. Arrows are represented by lists of length two, where a list represents the arrow from the first element to the second.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"graph1\" name=\"digraph\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMA> <OMS cd=\"set1\" name=\"map\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 1 </OMI> </OMA> </OMA> </OMBIND> </OMA> </OMA> </OMOBJ>"});
        register_omdef("graph1","arrowset","This symbol represents the set of arrows of a directed graph. It takes one argument, the directed graph.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"graph1\" name=\"arrowset\"></OMS> <OMA> <OMS cd=\"graph1\" name=\"digraph\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("graph1","source","Given an arrow, this symbol refers to the vertex where the arrow starts. It takes one argument, the arrow.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"graph1\" name=\"source\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> <OMV name=\"a\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("graph1","target","Given an arrow, this symbol refers to the vertex the arrow points to. It takes one argument, the arrow.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"graph1\" name=\"target\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> <OMV name=\"b\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("graph2",null,"This CD defines symbols for handling directed and undirected graphs. Authored by Arjeh---to be merged with version of Erik Postma.",new String[] {});
        register_omdef("graph2","automorphism_group","This symbol is a unary function whose argument is an undirected graph. When applied to an undirected graph G, it represents the automorphism group of G. The resulting automorphism group is represented as a permutation group on the vertices of the graph G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"graph2\" name=\"automorphism_group\"></OMS> <OMA><OMS cd=\"graph1\" name=\"graph\"></OMS> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMI>1</OMI><OMI>2</OMI><OMI>3</OMI> </OMA> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMI>2</OMI><OMI>3</OMI> </OMA> </OMA> </OMA> </OMA> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>3</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("graph2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are graphs M, N, the third is a map f from the vertex set of M to the vertex set of N. When applied to M, N, and f, it denotes that f is a graph homomorphism from M to N.",new String[] {});
        register_omdef("graph2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are graphs M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a graph isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"graph2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("graph2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a graph M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a graph endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"graph2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("graph2","is_automorphism","This symbol is a boolean function with two arguments. The first is a graph M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a graph automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"graph2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("graph2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are graphs. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"graph2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1",null,"A CD of basic functions for group theory",new String[] {});
        register_omdef("group1","group","This symbol is a constructor for groups. It takes four arguments in the following order: a set to specify the elements in the group, a binary operation to specify the group operation, an element to specify the identity, and a unary operation to specify inverses of group elements. Both the binary and unary operations should act on elements of the set and return an element of the set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"group1\" name=\"group\"></OMS> <OMA> <OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMS cd=\"alg1\" name=\"zero\"></OMS> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("group1","carrier","This symbol represents a unary function, whose argument should be a group G (for instance constructed by group). When applied to G, its value should be the set of elements of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> <OMV name=\"inverse\"></OMV> </OMA> </OMA> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1","multiplication","This symbol represents a unary function, whose argument should be a group G. It returns the multiplication map on G. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> <OMV name=\"inverse\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1","inversion","This symbol represents a unary function, whose argument should be a group G. It returns the map sending an element of G to its inverse.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"inversion\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> <OMV name=\"inverse\"></OMV> </OMA> </OMA> <OMV name=\"inverse\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1","identity","This symbols represents a unary function, whose argument should be a group. It returns the identity element of the group.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"identity\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> <OMV name=\"inverse\"></OMV> </OMA> </OMA> <OMV name=\"e\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative group.",new String[] {});
        register_omdef("group1","is_subgroup","The binary boolean function whose value is true iff the second argument is a subgroup of the second.",new String[] {});
        register_omdef("group1","monoid","This symbol is a unary function, whose argument should be a group G. When applied to G its value is the monoid underlying G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group1\" name=\"monoid\"></OMS> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group1","subgroup","This symbol is a constructor symbol with one or two arguments. The first argument is a list or set, D, of group elements. The optional second argument is the group G containing D. It denotes the subgroup of G generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group1\" name=\"subgroup\"></OMS> <OMV name=\"D\"></OMV> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group1\" name=\"subgroup\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"relation1\" name=\"neq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> 1 </OMI> <OMS cd=\"arith2\" name=\"inverse\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("group1","power","This is a symbol with three arguments. The first argument is a group G. Its second argument is an element g of G and the third argument is an integer k. It denotes the element g^k in G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"power\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> </OMA> <OMI>3</OMI> <OMI>2</OMI> </OMA> <OMI>6</OMI> </OMA> </OMOBJ>"});
        register_omdef("group1","expression","This symbol is a function with two arguments. Its first argument should be a group. The second should be an arithmetic expression A, whose operators are times and power, and whose leaves are members of the carrier of G. When applied to G and A, it denotes the element (of G) that is obtained from the leaves of A by applying the multiplication and the power map of G instead of the times and power from the CD arith1 appearing in A. The symbol alg1.one occurring in A will be interpreted as the identity of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"expression\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>6</OMI><OMI>3</OMI> </OMA> </OMA> <OMI>9</OMI> </OMA> </OMOBJ>"});
        register_omdef("group1","normal_closure","The binary function whose value is the set of conjugates of the elements of the second group by elements of the first, where multiplication between them is defined.",new String[] {});
        register_omdef("group1","is_normal","If G, H are the group arguments, then IsNormal(G,H) returns true precisely when H is normal in G. That is, inverse(g)*h*g is defined and contained in H for all h in H and g in G.",new String[] {});
        register_omdef("group2",null,"A CD of functions like homomorphisms for groups",new String[] {});
        register_omdef("group2","is_homomorphism","This symbol is a boolean function with three arguments. The first two arguments are groups M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a group homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are groups M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a group isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are groups. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a group M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a group endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group2","is_automorphism","This symbol is a boolean function with two arguments. The first is a group M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a group automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("group2","left_multiplication","This symbol is a function with two arguments, which should be a group M and an element x of M. When applied to M and x, it denotes left multiplication on M by x.",new String[] {});
        register_omdef("group2","right_multiplication","This symbol is a function with two arguments, which should be a group M and an element x of M. When applied to M and x, it denotes right multiplication on M by x.",new String[] {});
        register_omdef("group2","right_inverse_multiplication","This symbol is a function with two arguments, which should be a group M and an element x of M. When applied to M and x, it denotes right multiplication on M by the inverse of x.",new String[] {});
        register_omdef("group2","conjugation","This symbol is a function with two arguments, which should be a group M and an element x of M. When applied to M and x, it denotes conjugation on M by x.",new String[] {});
        register_omdef("group3",null,"A CD of group constructions",new String[] {});
        register_omdef("group3","automorphism_group","This is a function with a single argument which must be a group. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("group3","direct_product","This is an n-ary function whose arguments must be groups. It refers to the direct product of its arguments.",new String[] {});
        register_omdef("group3","direct_power","This is a binary function whose first argument should be a group G and whose second argument should be a natural number n. It refers to the direct product of n copies of G.",new String[] {});
        register_omdef("group3","sylow_subgroup","This symbol represents a binary function with two arguments, the first is a group G and the second a prime number p. When applied to G and p, it represents a Sylow p-subgroup of G (which is unique up to conjugacy in G).",new String[] {});
        register_omdef("group3","derived_subgroup","The unary function whose value is the subgroup of argument generated by all products of the form xyx^-1y^-1.",new String[] {});
        register_omdef("group3","quotient_group","The binary function whose value is the factor group of the first argument by the second, assuming the second is normal in the first.",new String[] {});
        register_omdef("group3","center","This symbols represents a unary function whose argument should be a group G. Its value is the biggest subgroup of G all of whose elements commute with all elements of G.",new String[] {});
        register_omdef("group3","centralizer","This symbols represents a binary function whose first argument should be a group G and whose second argument should be an element g or a list of elements L of the group G. Its value is the subgroup of G of all elements commuting with g or, if the second argument is a list, all elements of L.",new String[] {});
        register_omdef("group3","free_group","This symbol represents a unary function. The argument is a list or a set. When evaluated on such an argument, the function represents the free group generated by the entries of the list or set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group3\" name=\"free_group\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("group3","GL","This symbol is a function with one argument, which should be a vector space or a module V. When applied to V it represents the group of all invertible linear transformations of V.",new String[] {});
        register_omdef("group3","SL","This symbol is a function with one argument, which should be a a module V over a commutative ring. When applied to V it represents the group of all invertible linear transformations of V of determinant 1.",new String[] {});
        register_omdef("group3","GLn","This symbol is a function with two arguments. The first should be a positive integer n, the second a field F. When applied to n and F it represents the group of all invertible linear transformations of the vector space over F of dimension n.",new String[] {});
        register_omdef("group3","SLn","This symbol is a function with two arguments. The first should be a positive integer n, the second a field F. When applied to n and F it represents the group of all invertible linear transformations of the vector space over F of dimension n having determinant 1.",new String[] {});
        register_omdef("group3","normalizer","This symbols represents a binary function whose first argument should be a group G and whose second argument should be a set of elements or a subgroup L of the group G. Its value is the subgroup of G of all elements normalizing L.",new String[] {});
        register_omdef("group3","symmetric_group","This symbol is a function with one argument, which should be a set X. When applied to a set X it represents the group of all permutations on X .",new String[] {});
        register_omdef("group3","symmetric_groupn","This symbol is a function with one argument, which should be a natural number n. When applied to n it represents the group of all permutations on the set {1,2,... ,n}.",new String[] {});
        register_omdef("group3","alternating_group","This symbol is a function with one argument, which should be a set X. When applied to a set X it represents the group of all even permutations on X .",new String[] {});
        register_omdef("group3","alternatingn","This symbol is a function with one argument, which should be a natural number n. When applied to n it represents the group of all even permutations on the set {1,2, ...,n}.",new String[] {});
        register_omdef("group3","invertibles","This symbol is a function with one argument, which should be a monoid M. When applied to M it represents the group of all invertible elements of M.",new String[] {});
        register_omdef("group4",null,"A CD of sets constructed from groups",new String[] {});
        register_omdef("group4","conjugacy_classes","This symbol represents a unary function whose argument should be a group. Its value on a group is the set of conjugacy classes of that group.",new String[] {});
        register_omdef("group4","conjugacy_class_representatives","This symbol represents a unary function whose argument should be a group. Its value on a group is a set of representatives of the conjugacy classes of that group.",new String[] {});
        register_omdef("group4","are_conjugate","This symbol represents a boolean ternary function whose first argument is a group G and whose second and third arguments are elements x and y of G. Its value on G, x, and y is true if and only if x and y are conjugate in G.",new String[] {});
        register_omdef("group4","conjugacy_class","This symbol represents a binary function, whose first argument is a group G and whose second argument is an element x of G. Its value on G and x is the set of elements which are conjugate to x in G.",new String[] {});
        register_omdef("group4","left_transversal","The binary function whose value is a set of representatives for the left cosets of the second argument as a subgroup of the first.",new String[] {});
        register_omdef("group4","right_transversal","The binary function whose value is a set of representatives for the right cosets of the second argument as a subgroup of the first.",new String[] {});
        register_omdef("group4","left_coset","This symbol represents a ternary function whose first argument is a group G, whose second argument is a subgroup H of G, and whose third argument is an element x of G. Its value on G, H, and x is the left coset of H in G containing x, that is, the set x H.",new String[] {});
        register_omdef("group4","right_coset","This symbol represents a ternary function whose first argument is a group G, whose second argument is a subgroup H of G, and whose third argument is an element x of G. Its value on G, H, and x is the right coset of H in G containing x, that is, the set H x.",new String[] {});
        register_omdef("group4","left_cosets","The binary function whose value is the set of left cosets of the second argument in the first.",new String[] {});
        register_omdef("group4","right_cosets","The binary function whose value is the set of right cosets of the second argument in the first.",new String[] {});
        register_omdef("group4","left_coset_representative","This symbol represents a quaternary function whose first argument is a group G, whose second argument is a subgroup H of G, whose third argument is left_transversal T of H in G, and whose fourth argument is an element of G. It assigns to G, H, T, g the element of t of T representing the left coset of H containing g, that is, t H = g H .",new String[] {});
        register_omdef("group4","right_coset_representative","This symbol represents a quaternary function whose first argument is a group G, whose second argument is a subgroup H of G, whose third argument is right_transversal T of H in G, and whose fourth argument is an element of G. It assigns to G, H, T, g the element of t of T representing the right coset of H containing g, that is, H t = H g.",new String[] {});
        register_omdef("group5",null,"A CD of functions for relating group elements to their images in quotients.",new String[] {});
        register_omdef("group5","right_quotient_map","This symbol is a binary function whose first argument is a group G and whose second argument is an subgroup H of G. When applied to G and H, its value is the natural quotient map from G to the quotient group G/H, sending x to the left coset xH of G.",new String[] {});
        register_omdef("group5","left_quotient_map","This symbol is a binary function whose first argument is a group G and whose second argument is an subgroup H of G. When applied to G and H, its value is the natural quotient map from G to the quotient group G/H, sending x to the right coset Hx of G.",new String[] {});
        register_omdef("group5","homomorphism_by_generators","This is a function with three arguments the first two of which must be groups F and K. The third argument should be a set or a list L of ordered pairs (lists of length 2). Each pair [x,y] from L consists of an element x from F and an element y from K. When applied to F, K, and L, the symbol represents the group homomorphism from F to K that maps the first entry x of each pair [x,y] to the second entry y of the same pair.",new String[] {});
        register_omdef("groupname1",null,"Well known groups in group theory",new String[] {});
        register_omdef("groupname1","quaternion_group","This symbol represents the quaternion group of order 8.",new String[] {});
        register_omdef("groupname1","dihedral_group","This symbol is a function with one argument, which should be a positive integer n. When applied to n it represents the dihedral group of order 2n. This is the group of all isometries (including reflections) of the regular n-gon in the plane.",new String[] {});
        register_omdef("groupname1","cyclic_group","This symbol is a function with one argument, which should be a natural number n. When applied to n it represents the cyclic group of order n.",new String[] {});
        register_omdef("groupname1","generalized_quaternion_group","This symbol is a function with one argument, which should be a positive integer. When applied to n it represents the generalized quaternion group of order 4n. This is the group with three generators a, b, and c and relations c = a^2 = b^n, c*a = a*c , b*c = c*b, a*b = b*a*c, and c^2 = 1.",new String[] {});
        register_omdef("icc",null,"ICC Typing Attributes for OM Initial version: O. Caprotti (July 1, 1999)",new String[] {});
        register_omdef("icc","type","Attribution tag to denote type-judgement",new String[] {});
        register_omdef("icc","typecoerce","Attribution tag to denote type-judgement with coercion",new String[] {});
        register_omdef("icc","IndType","Constructor for Inductive Types. Takes arguments the constructor functions for the inhabitants of the type and their signatures.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"icc\" name=\"IndType\"></OMS> <OMATTR> <OMATP> <OMS cd=\"icc\" name=\"type\"></OMS> <OMS cd=\"setname1\" name=\"N\"></OMS> </OMATP> <OMI> 0 </OMI> </OMATTR> <OMATTR> <OMATP> <OMS cd=\"icc\" name=\"type\"></OMS> <OMA> <OMS cd=\"lc\" name=\"mapsto\"></OMS> <OMS cd=\"setname1\" name=\"N\"></OMS> <OMS cd=\"setname1\" name=\"N\"></OMS> </OMA> </OMATP> <OMS cd=\"indnat\" name=\"succ\"></OMS> </OMATTR> </OMA> </OMOBJ>"});
        register_omdef("indnat",null,"Inductive definition of natural numbers Initial version: O.C (Jan. 2000)",new String[] {});
        register_omdef("indnat","indNat","Attribution tag to denote the type of inductively defined natural numbers. It is also denoted as setname1:N.",new String[] {});
        register_omdef("indnat","zero","The natural number 0, also constant base function for the inductive definition of the type of natural numbers",new String[] {});
        register_omdef("indnat","succ","Successor function on the natural number. Constructor for the inductively defined natural numbers. Takes argument a a natural number and returns a natural number.",new String[] {});
        register_omdef("indnat","plus","Addition of natural numbers defined recursively by using the successor.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"indnat\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMA><OMS cd=\"indnat\" name=\"succ\"></OMS> <OMV name=\"m\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"indnat\" name=\"succ\"></OMS> <OMA><OMS cd=\"indnat\" name=\"plus\"></OMS> <OMV name=\"n\"></OMV> <OMV name=\"m\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("indnat","times","Multiplication of natural numbers defined recursively by using the successor and plus.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"indnat\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMA> <OMS cd=\"indnat\" name=\"succ\"></OMS> <OMV name=\"m\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"indnat\" name=\"plus\"></OMS> <OMA><OMS cd=\"indnat\" name=\"times\"></OMS> <OMV name=\"n\"></OMV> <OMV name=\"m\"></OMV> </OMA> <OMV name=\"n\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("integer1",null,"This CD holds a collection of basic integer functions. This CD is intended to be `compatible\\\' with the corresponding elements in Content MathML.",new String[] {});
        register_omdef("integer1","factorof","This is the binary OpenMath operator that is used to indicate the mathematical relationship a \\\"is a factor of\\\" b, where a is the first argument and b is the second. This relationship is true if and only if b mod a = 0.",new String[] {});
        register_omdef("integer1","factorial","The symbol to represent a unary factorial function on non-negative integers.",new String[] {});
        register_omdef("integer1","quotient","The symbol to represent the integer (binary) division operator. That is, for integers a and b, quotient(a,b) denotes q such that a=b*q+r, with |r| less than |b| and a*r positive.",new String[] {});
        register_omdef("integer1","remainder","The symbol to represent the integer remainder after (binary) division. For integers a and b, remainder(a,b) denotes r such that a=b*q+r, with |r| less than |b| and a*r positive.",new String[] {});
        register_omdef("integer2",null,"This CD holds a collection of basic modular arithmetic for integers.",new String[] {});
        register_omdef("integer2","modulo_relation","This symbol represents a univariate function, whose argument should be an integer. When applied to an integer m, it denotes the equivalence relation of being equal modulo m on Z.",new String[] {});
        register_omdef("integer2","divides","This symbol represents a bivariate Boolean function, whose arguments should be integers. When applied to integers a and b, it denotes the property that a divides b.",new String[] {});
        register_omdef("integer2","eqmod","This symbol represents a Boolean valued trivariate function, whose arguments should be integers. When applied to integers a, b, m, it denotes the Boolean evalue of the assertion that a and b are equal modulo m.",new String[] {});
        register_omdef("integer2","neqmod","This symbol represents a Boolean valued trivariate function, whose arguments should be integers. When applied to integers a, b, m, it denotes the Boolean evalue of the assertion that a and b are not equal modulo m.",new String[] {});
        register_omdef("integer2","class","This symbol represents a bivariate function, whose arguments should be integers. If a, m are integers, then class(a,m) denotes the residue class a mod m in setname2.Zm.",new String[] {});
        register_omdef("integer2","euler","This symbol denotes the univariate Euler totient function. If m is an integer, then euler(m) denotes the order of the multiplicative group of invertible elements in the residue class ring Z/mZ.",new String[] {});
        register_omdef("integer2","ord","This symbol denotes a binary function. Its first argument shoud be a prime number p, the second an integer n. When applied to p and n, it represents the highest power of p occurring in a factorization of n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"integer2\" name=\"ord\"></OMS> <OMA><OMS cd=\"integer2\" name=\"ord\"></OMS> <OMI>2</OMI> <OMI>60</OMI> </OMA> <OMI>2</OMI> </OMA> </OMOBJ>"});
        register_omdef("interval1",null,"This CD holds symbols which describe both discrete and continuous 1-dimensional intervals (with open/closed end points).",new String[] {});
        register_omdef("interval1","integer_interval","A symbol to denote a discrete 1 dimensional interval from the first argument to the second (inclusive), where the discretisation occurs at unit intervals. The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> </OMOBJ>"});
        register_omdef("interval1","interval","A symbol to denote a continuous 1-dimensional interval without any information about the character of the end points (used in definite integration). The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"interval\"></OMS> <OMF dec=\"1.0\"></OMF> <OMF dec=\"10.0\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("interval1","interval_oo","A symbol to denote a continuous 1-dimensional interval with both end points excluded from the interval. The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"interval_oo\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> </OMOBJ>"});
        register_omdef("interval1","interval_cc","A symbol to denote a continuous 1-dimensional interval with both end points included in the interval. The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"interval_cc\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> </OMOBJ>"});
        register_omdef("interval1","interval_oc","A symbol to denote a continuous 1-dimensional interval with the first point excluded from the interval, but the last included. The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"interval_oc\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> </OMOBJ>"});
        register_omdef("interval1","interval_co","A symbol to denote a continuous 1-dimensional interval with the first point included in the interval, but the last excluded. The arguments are the start and the end points of the interval in that order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"interval1\" name=\"interval_co\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> </OMOBJ>"});
        register_omdef("lc",null,"Lambda Calculus Initial version: O. Caprotti",new String[] {});
        register_omdef("lc","type","Attribution tag to denote type-judgement",new String[] {});
        register_omdef("lc","typecoerce","Attribution tag to denote type-judgement with coercion",new String[] {});
        register_omdef("lc","PiType","The type constructor of dependant function space. It binds the (type-attributed) variables in the body, that is an OpenMath object.",new String[] {});
        register_omdef("lc","mapsto","The type constructor of non-dependant function space. The first n-1 children denote the types of the arguments, the last denotes the return type. Contrary to sts:mapsto, arguments cannot be variables but have to be OpenMath objects that map to ground OpenMath terms (they contain no variables).",new String[] {});
        register_omdef("lc","Lambda","The abstraction constructor. It is followed by a list of variables and an OpenMath object.",new String[] {});
        register_omdef("limit1",null,"This CD holds the basic notion of the limits of unary functions whilst its variable tend (either from above, below or both sides) to a particular value.",new String[] {});
        register_omdef("limit1","limit","This symbol is used to denote the limit of a unary function. It takes 3 arguments: the limiting value of the argument, the method of approach (either null, above, below or both_sides) and the function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"limit1\" name=\"limit\"></OMS> <OMI> 0 </OMI> <OMS cd=\"limit1\" name=\"both_sides\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("limit1","both_sides","This symbol is used within a limit construct to show the limit is being approached from both sides. It takes no arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"limit1\" name=\"limit\"></OMS> <OMI> 0 </OMI> <OMS cd=\"limit1\" name=\"both_sides\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("limit1","above","This symbol is used within a limit construct to show the limit is being approached from above. It takes no arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"limit1\" name=\"limit\"></OMS> <OMI> 0 </OMI> <OMS cd=\"limit1\" name=\"above\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("limit1","below","This symbol is used within a limit construct to show the limit is being approached from below. It takes no arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"limit1\" name=\"limit\"></OMS> <OMI> 0 </OMI> <OMS cd=\"limit1\" name=\"below\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("limit1","null","This symbol is used within a limit construct to avoid specifying the method of approach to the limit. It takes no arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"limit1\" name=\"limit\"></OMS> <OMI> 0 </OMI> <OMS cd=\"limit1\" name=\"null\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("linalg1",null,"Operations on Matrices (independent of the matrix representation).",new String[] {});
        register_omdef("linalg1","vectorproduct","This symbol represents the vector product function. It takes two three dimensional vector arguments and returns a three dimensional vector. It is defined as follows: if we write a as [a_1,a_2,a_3] and b as [b_1,b_2,b_3] then the vector product denoted a x b = [a_2b_3 - a_3b_2 , a_3b_1 - a_1b_3 , a_1b_2 - a_2b_1]. Note that the vector product is often referred to as the cross product.",new String[] {});
        register_omdef("linalg1","scalarproduct","This symbol represents the scalar product function. It takes two vector arguments and returns a scalar value. The scalar product of two vectors a, b is defined as |a| * |b| * cos(\\\\theta), where \\\\theta is the angle between the two vectors and |.| is a euclidean size function. Note that the scalar product is often referred to as the dot product.",new String[] {});
        register_omdef("linalg1","outerproduct","This symbol represents the outer product function. It takes two vector arguments and returns a matrix. It is defined as follows: if we write the {i,j}\\\'th element of the matrix to be returned as m_{i,j}, then: m_{i,j}=a_i * b_j where a_i,b_j are the i\\\'th and j\\\'th elements of a, b respectively.",new String[] {});
        register_omdef("linalg1","transpose","This symbol represents a unary function that denotes the transpose of the given matrix or vector",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"linalg1\" name=\"transpose\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 0 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 0 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 1 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg1","determinant","This symbol denotes the unary function which returns the determinant of its argument, the argument should be a square matrix.",new String[] {});
        register_omdef("linalg1","vector_selector","This symbol represents the function which allows individual entries to be selected from a vector, or a matrixrow. It takes two arguments. The first argument is the position in the vector (or matrixrow) of the required entry, the second argument is the vector (or matrixrow) in question. The indexing is one based, i.e. the first element is indexed by one.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg1\" name=\"vector_selector\"></OMS> <OMI>2</OMI> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg1\" name=\"vector_selector\"></OMS> <OMI>2</OMI> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 0 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg1","matrix_selector","This symbol represents the function which allows individual entries to be selected from a matrix. It takes three arguments, the first is the index of the row and the second is the index of the column of the required element, the third argument is the matrix in question. The indexing is one based, i.e. the element in the top left hand corner is indexed by (1,1).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg1\" name=\"matrix_selector\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("linalg2",null,"This CD treats matrices and vectors in a row oriented fashion (using matrixrow\\\'s).",new String[] {});
        register_omdef("linalg2","vector","This symbol represents an n-ary function used to construct (or describe) vectors. Vectors in this CD are considered to be row vectors and must therefore be transposed to be considered as column vectors.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg2","matrixrow","This symbol is an n-ary constructor used to represent rows of matrices. Its arguments should be members of a ring.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg2","matrix","This symbol is an n-ary matrix constructor which requires matrixrow\\\'s as arguments. It is used to represent matrices.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI> 0 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg3",null,"This CD treats matrices and vectors in a column oriented fashion (using matrixcolumn\\\'s).",new String[] {});
        register_omdef("linalg3","vector","This symbol represents an n-ary function used to construct (or describe) vectors. Vectors in this CD are considered to be column vectors, and must therefore be transposed to be considered as row vectors.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg3\" name=\"vector\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg3","matrixcolumn","This symbol is an n-ary constructor used to represent columns of matrices. Its arguments should be members of a ring.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg3\" name=\"matrixcolumn\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg3","matrix","This symbol is an n-ary matrix constructor which requires matrixcolumn\\\'s as arguments. It is used to represent matrices.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg3\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg3\" name=\"matrixcolumn\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"linalg3\" name=\"matrixcolumn\"></OMS> <OMI> 0 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg4",null,"This CD defines symbols for basic linear algebra. Regardless of the way of forming vectors and matrices, this CD deals with eigenvalues, eigenvectors and related concepts.",new String[] {});
        register_omdef("linalg4","eigenvalue","This symbol represents the eigenvalue of a matrix. It takes two arguments the first should be the matrix, the second should be an index to specify the eigenvalue. The ordering imposed on the eigenvalues is first on the modulus of the value, and second on the argument of the value. A definition of eigenvalue is given in Elementary Linear Algebra, Stanley I. Grossman in Definition 1 of chapter 6, page 533.",new String[] {});
        register_omdef("linalg4","eigenvector","This symbol represents the eigenvector of a matrix. It takes two arguments the first should be the matrix, the second should be an index to specify which eigenvalue this eigenvector should be paired with. The ordering is as given in the eigenvalue symbol. A definition of eigenvector is given in Elementary Linear Algebra, Stanley I. Grossman in Definition 1 of chapter 6, page 533.",new String[] {});
        register_omdef("linalg4","characteristic_eqn","This symbol represents the polynomial which appears in the left hand side of the characteristic equation of a matrix. It takes one argument which should be the matrix. A definition of the characteristic equation is given in Elementary Linear Algebra, Stanley I. Grossman in Definition 2 of chapter 6, page 535.",new String[] {});
        register_omdef("linalg4","size","This symbol represents the function which takes one vector argument and returns the length of that vector.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"linalg4\" name=\"size\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg4","rank","This symbol represents the function which takes one matrix argument and returns the number of linearly independent rows (or columns) of that matrix.",new String[] {});
        register_omdef("linalg4","rowcount","This symbol represents the function which takes one matrix argument and returns the number of rows in that matrix.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg4\" name=\"rowcount\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>3</OMI> <OMI>4</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>5</OMI> <OMI>6</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg4","columncount","This symbol represents the function which takes one matrix argument and returns the number of columns in that matrix.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg4\" name=\"columncount\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrix\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>3</OMI> <OMI>4</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"matrixrow\"></OMS> <OMI>5</OMI> <OMI>6</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5",null,"This CD contains symbols which represent a number of special types of matrix.",new String[] {});
        register_omdef("linalg5","identity","This symbol denotes a unary function which is used to construct an (nxn) identity matrix where n is the single positive integral argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"identity\"></OMS> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg5","zero","This symbol denotes a function with two integral arguments m,n which is used to construct an (mxn) zero matrix.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"zero\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg5","diagonal_matrix","This symbol denotes an n_ary function which is used to construct an (nxn) diagonal matrix, that is a matrix where every non-diagonal element is zero, the diagonal elements are equal to the n arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"diagonal_matrix\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("linalg5","scalar","This symbol represents a matrix which is a scalar constant times the identity matrix. It should take two arguments, the first specifes the number of rows and columns in the matrix respectively and the third specifies the scalar multiplier.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"scalar\"></OMS> <OMI>4</OMI> <OMF dec=\"1.5\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("linalg5","constant","This symbol represents a matrix which has all entries of the same value. It takes two arguments, the first is the size of the matrix, the second is the constant which determines every element.",new String[] {});
        register_omdef("linalg5","banded","This symbol represents a (p,q) banded matrix, it takes one argument. A (p,q) banded matrix should always be square. The lower non-zero subdiagonal is the first element of the argument, whilst the highest non-zero super-diagonal is given by the last element of the argument. The argument determines the band of possibly non-zero entries which are positioned around the diagonal. It should be a vector of vectors, we note that they will not all be the same length, however the length of the vectors determine p and q. The longest element specifies the diagonal of the matrix and hence the size of the matrix. Every element not in the band is zero.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"banded\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>4</OMI> <OMI>8</OMI> <OMI>12</OMI> <OMI>15</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>5</OMI> <OMI>9</OMI> <OMI>13</OMI> <OMI>16</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>2</OMI> <OMI>6</OMI> <OMI>10</OMI> <OMI>14</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>3</OMI> <OMI>7</OMI> <OMI>11</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","symmetric","This symbol represents a symmetric matrix, it takes one argument. The argument should be a vector of vectors of elements of the matrix. For j>=i the ij\\\'th element of the matrix is the (j-i+1)\\\'th element of the i\\\'th element of the argument. This determines the upper triangle of the matrix, the lower triangle is specified by the rule M = transpose M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"symmetric\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 5 </OMI> <OMI> 6 </OMI> <OMI> 7 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 8 </OMI> <OMI> 9 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 10 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","skew-symmetric","This symbol represents a skew-symmetric matrix, it takes one argument. The argument should be a vector of vectors of elements of the matrix. For j>i the ij\\\'th element of the matrix is the (j-i+1)\\\'th element of the i\\\'th element of the argument. This determines the elements above the diagonal of the matrix, the elements below the diagonal of the matrix must conform to the rule M = - transpose M. This rule implies that the elements on the diagonal must be equal to 0, therefore we do not include these in the argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"skew-symmetric\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 6 </OMI> <OMI> 7 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 9 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","Hermitian","This symbol represents a Hermitian matrix, it takes one argument. The argument should be a vector of vectors of values which determine the upper triangle of the matrix. The lower triangle of the matrix is specified by the following relation: M^* = transpose(M), were M^* denotes the matrix consisting of all the complex conjugates of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"Hermitian\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"complex1\" name=\"complex_cartesian\"></OMS> <OMI> 1 </OMI><OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"complex1\" name=\"complex_cartesian\"></OMS> <OMI> 2 </OMI><OMI> 2 </OMI> </OMA> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"complex1\" name=\"complex_cartesian\"></OMS> <OMI> 3 </OMI><OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","anti-Hermitian","This symbol represents an anti-Hermitian matrix, it takes one argument. The argument should be a vector of vectors of values which determine the upper triangle of the matrix. The lower triangle of the matrix is specified by the following relation: - M^* = transpose(M), were M^* denotes the matrix consisting of all the complex conjugates of M. This rules implies that the main diagonal is zero, therefore the argument should not include it.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"anti-Hermitian\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"complex1\" name=\"complex_cartesian\"></OMS> <OMI> 1 </OMI><OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","upper-triangular","This symbol represents an upper-triangular matrix, it takes one argument. The argument should be a vector of vectors of elements of the matrix.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"upper-triangular\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 1 </OMI><OMI> 2 </OMI><OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 4 </OMI><OMI> 5 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 6 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","lower-triangular","This symbol represents a lower-triangular matrix, it takes one argument. The argument should be a vector of vectors of elements of the matrix.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"lower-triangular\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 2 </OMI><OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI> 4 </OMI><OMI> 5 </OMI><OMI> 6 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","upper-Hessenberg","This symbol represents an upper-Hessenberg matrix, it takes one argument, the argument is a vector of vectors representing the non-zero elements. The first element of the argument specifies the value of the first subdiagonal, the subsequent elements specify the value of the diagonal and subsequent super-diagonals, all other elements are zero.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"upper-Hessenberg\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>4</OMI> <OMI>8</OMI> <OMI>12</OMI> <OMI>15</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>5</OMI> <OMI>9</OMI> <OMI>13</OMI> <OMI>16</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>2</OMI> <OMI>6</OMI> <OMI>10</OMI> <OMI>14</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>3</OMI> <OMI>7</OMI> <OMI>11</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","lower-Hessenberg","This symbol represents a lower-Hessenberg matrix, it takes one argument, the argument is a vector of vectors representing the non-zero elements. The first element of the argument specifies the value of the first super-diagonal, the subsequent elements specify the value of the diagonal and subsequent subdiagonals, all other elements are zero.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"linalg5\" name=\"lower-Hessenberg\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>2</OMI> <OMI>5</OMI> <OMI>9</OMI> <OMI>13</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>4</OMI> <OMI>8</OMI> <OMI>12</OMI> <OMI>16</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>3</OMI> <OMI>7</OMI> <OMI>11</OMI> <OMI>15</OMI> </OMA> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>6</OMI> <OMI>10</OMI> <OMI>14</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("linalg5","tridiagonal","This symbol represents a tridiagonal matrix, it takes one argument which should be a vector of vectors which should have three elements. These should be vectors representing the sub-diagonal, the diagonal and the super-diagonal in that order.",new String[] {});
        register_omdef("linalg6",null,"This CD contains symbols for the construction of some new matrices from old ones.",new String[] {});
        register_omdef("linalg6","matrix_tensor","This symbol denotes a n-nary function which is used to construct the tensor product matrix of its arguments, which must be matrices.",new String[] {});
        register_omdef("linalg6","vector_tensor","This symbol denotes a n-nary function which is used to construct the tensor product vector of its arguments, which must be vectors.",new String[] {});
        register_omdef("linalg7",null,"This CD contains symbols for the construction of matrices from lists.",new String[] {});
        register_omdef("linalg7","list_to_vector","This symbol denotes a binary function. Its first argument must be a ring R, its second argument must be list L with entries belonging to the ring R, up to ring1.expression. When applied to R and L it represents the vector of the same length as the list L whose i-th coordinate is L[i] (or ring1.expression(L[i])).",new String[] {});
        register_omdef("linalg7","list_to_matrix","This symbol denotes a binary function. Its first argument must be a ring R, its second argument must be list L of lists of equal lengths whose entries belong to the ring R, up to ring1.expression. When applied to R and L it represents the matrix whose i,j entry consists of the j-th entry from the list L[i]. In particular, the matrix has length(L) rows and length(L[1]) columns.",new String[] {});
        register_omdef("list1",null,"This CD is intended to be `compatible\\\' with MathML list constructs.",new String[] {});
        register_omdef("list1","map","This symbol represents a mapping function which may be used to construct lists, it takes as arguments a function from X to Y and a list over X in that order. The value that is returned is a list of values in Y. The argument list may be a set or an integer_interval.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"list1\" name=\"map\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> 2 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> <OMA> <OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 0 </OMI> <OMI> 10 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list1","suchthat","This symbol represents the suchthat function which may be used to construct lists, it takes two arguments. The first argument should be the set which contains the elements of the list, the second argument should be a predicate, that is a function from the set to the booleans which describes if an element is to be in the list returned.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"list1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"logic1\" name=\"and\"></OMS> <OMA> <OMS cd=\"relation1\" name=\"geq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> <OMA> <OMS cd=\"relation1\" name=\"lt\"></OMS> <OMV name=\"x\"></OMV> <OMI> 100 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("list1","list","This symbol denotes the list construct which is an n-ary function. The list entries must be given explicitly.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMOBJ>"});
        register_omdef("list2",null,"Several basic list functions are given in this CD.",new String[] {});
        register_omdef("list2","list_selector","This symbol takes a positive integer n and a list, and represents the n-th element of that list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"b\"></OMV> <OMA> <OMS cd=\"list2\" name=\"list_selector\"></OMS> <OMI> 2 </OMI> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> <OMV name=\"c\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list2","first","This symbol represents a function which returns the first elements of its argument, which should be a list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"list2\" name=\"first\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list2","rest","This symbol represents a function which returns a list made up of all the elements except the first of its argument, which should be a list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"list2\" name=\"rest\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list2","cons","This symbol represents the cons list function. It takes 2 arguments: the second must be a list, where the elements have the same type as the type of the first. The function denotes a new list which has the first argument as its first element followed by the elements of the second argument.",new String[] {});
        register_omdef("list2","nil","The empty list",new String[] {});
        register_omdef("list2","append","The operation of joining one list to another",new String[] {});
        register_omdef("list2","reverse","The reverse of a list",new String[] {});
        register_omdef("list2","size","This symbol is used to denote the number of elements in a list. It is either a non-negative integer.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"list2\" name=\"size\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("list2","in","This symbol has two arguments, an element and a list. It is used to denote that the element is in the given list.",new String[] {});
        register_omdef("list3",null,"Several basic list functions related to length are given in this CD.",new String[] {});
        register_omdef("list3","length","This symbol represents a function whose argument should be a list. It returns the length of its argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"list3\" name=\"length\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("list3","list_of_lengthn","This symbol represents a function with two arguments, the first of which is a natural number and the second of which is a list. The first argument is the length of the list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"list3\" name=\"list_of_lengthn\"></OMS> <OMI> 3 </OMI> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"L\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list3","entry","This symbol represents a binary function whose first argument should be a list L and whose second argument should be a positive integer i such that the absolute value of i is in the interval [1..n], where n is the length of L. If i is positive, it returns the i-th entry L[i] of L, if i is negative it returns the (n+1-i)-th entry of L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"list3\" name=\"entry\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMI> 2 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"list3\" name=\"entry\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 4 </OMI> <OMI> 5 </OMI> <OMI> 6 </OMI> </OMA> <OMI>-2</OMI> </OMA> <OMI>5</OMI> </OMA> </OMOBJ>"});
        register_omdef("list3","difference","This symbol takes two arguments both a list. It represents a function which returns a list made up of all the elements of the first list which are not in the second.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"list3\" name=\"difference\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 4 </OMI> <OMI> 5 </OMI> <OMI> 6 </OMI> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 4 </OMI> <OMI> 5 </OMI> <OMI> 6 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("list3","select","This symbol takes two lists as arguments, L and M say. The second argument is a list containing only entries from [1..n], where n is the length of L. The symbol represents the function which returns a list whose length is equal to the length of M, and having at position k the value of L at position M_k.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"list3\" name=\"select\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 4 </OMI> <OMI> 5 </OMI> <OMI> 6 </OMI> <OMI> 7 </OMI> <OMI> 8 </OMI> <OMI> 9 </OMI> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 3 </OMI> <OMI> 5 </OMI> <OMI> 2 </OMI> <OMI> 2 </OMI> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 6 </OMI> <OMI> 8 </OMI> <OMI> 5 </OMI> <OMI> 5 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("logic1",null,"This CD holds the basic logic functions.",new String[] {});
        register_omdef("logic1","equivalent","This symbol is used to show that two boolean expressions are logically equivalent, that is have the same boolean value for any inputs.",new String[] {});
        register_omdef("logic1","not","This symbol represents the logical not function which takes one boolean argument, and returns the opposite boolean value.",new String[] {});
        register_omdef("logic1","and","This symbol represents the logical and function which is an n-ary function taking boolean arguments and returning a boolean value. It is true if all arguments are true or false otherwise.",new String[] {});
        register_omdef("logic1","xor","This symbol represents the logical xor function which is an n-ary function taking boolean arguments and returning a boolean value. It is true if there are an odd number of true arguments or false otherwise.",new String[] {});
        register_omdef("logic1","or","This symbol represents the logical or function which is an n-ary function taking boolean arguments and returning a boolean value. It is true if any of the arguments are true or false otherwise.",new String[] {});
        register_omdef("logic1","implies","This symbol represents the logical implies function which takes two boolean expressions as arguments. It evaluates to false if the first argument is true and the second argument is false, otherwise it evaluates to true.",new String[] {});
        register_omdef("logic1","true","This symbol represents the boolean value true.",new String[] {});
        register_omdef("logic1","false","This symbol represents the boolean value false.",new String[] {});
        register_omdef("magma1",null,"Basic functions for magma theory",new String[] {});
        register_omdef("magma1","magma","This symbol is a constructor for magmas. It takes two arguments in the following order: a set to specify the elements in the magma and a binary operation to specify the magma operation. The binary operation should act on elements of the set and return an element of the set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV><OMV name=\"y\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI>2</OMI> </OMA> <OMV name=\"y\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("magma1","carrier","This symbol represents a unary function, whose argument should be a magma G (for instance constructed by magma). When applied to G, its value should be the set of elements of a magma.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"magma1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma1","multiplication","This symbol represents a unary function, whose argument should be a magma G. It returns the multiplication map on G. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"magma1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative magma.",new String[] {});
        register_omdef("magma1","is_associative","The unary boolean function whose value is true iff the argument is an associative magma.",new String[] {});
        register_omdef("magma1","is_submagma","The binary boolean function whose value is true iff the second argument is a submagma of the first.",new String[] {});
        register_omdef("magma1","is_identity","This symbols represents a binary boolean function, whose arguments should be a magma and an element of the element set of the magma. When applied to the arguments M and x, it returns true if the element x is an identity of the magma M, that is, x*y = y* x = y for all elements y of M.",new String[] {});
        register_omdef("magma1","submagma","This symbol is a constructor symbol with two arguments. The first argument is a magma M, the second a list or set, D, of elements of M. When applied to M and D, it denotes the submagma of M generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma1\" name=\"submagma\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"D\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"relation1\" name=\"neq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> </OMA> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("magma1","left_divides","This symbol is a ternary function. Its first argument should be a magma M and the second and third arguments should be elements of M. When applied to M, a, and b, it denotes the fact that a is a left_divisor of b in M. This means that there is v in M such that av=b.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma1\" name=\"left_divides\"></OMS> <OMV name=\"M\"></OMV><OMV name=\"a\"></OMV><OMV name=\"b\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma1","right_divides","This symbol is a ternary function. Its first argument should be a magma M and the second and third arguments should be elements of M. When applied to M, a, and b, it denotes the fact that a is a right_divisor of b in M. This means that there is v in M such that va = b.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma1\" name=\"right_divides\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma1","left_expression","This symbol is a binary function. Its first argument should be a magma M, the second argument a list L of elements of M. When applied to M and L, it denotes the left product (L[1] * ( ... (L[n-1] * L[n]) ... )) of all elements in the list L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"magma1\" name=\"left_expression\"></OMS> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>3</OMI><OMI>2</OMI> </OMA> </OMA> <OMI>6</OMI> </OMA> </OMOBJ>"});
        register_omdef("magma1","right_expression","This symbol is a binary function. Its first argument should be a magma M, the second argument a list L of elements of M When applied to M and L, it denotes the right product (( ... (L[1] * L[2]) * ... ) * L[n]) of all elements in the list L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"magma1\" name=\"right_expression\"></OMS> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>3</OMI><OMI>2</OMI> </OMA> </OMA> <OMI>6</OMI> </OMA> </OMOBJ>"});
        register_omdef("magma2",null,"Basic functions for magma theory",new String[] {});
        register_omdef("magma2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are magmas M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a magma homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are magmas M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a magma isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a magma M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a magma endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma2","is_automorphism","This symbol is a boolean function with two arguments. The first is a magma M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a magma automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are magmas. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("magma3",null,"Basic functions for magma theory",new String[] {});
        register_omdef("magma3","automorphism_group","This is a function with a single argument which must be a magma. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("magma3","direct_product","This is an n-ary function whose arguments must be magmas. It refers to the direct product of its arguments.",new String[] {});
        register_omdef("magma3","free_magma","This symbol represents a binary function. The argument is a list or a set. When evaluated on such an argument, the function represents the free magma generated by the entries of the list or set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"magma3\" name=\"free_magma\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("mathmltypes",null,"This CD holds symbols denoting various types of numbers, vectors and similar constructs. Principally these are required for compatibility with MathML.",new String[] {});
        register_omdef("mathmltypes","type","A symbol to be used within an OpenMath attribute to specify the type of the object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"complex_polar_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","integer_type","A symbol to be used as the argument of the type symbol to convey the type of an integer.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"integer_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","real_type","A symbol to be used as the argument of the type symbol to convey the type of a real number.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"real_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","rational_type","A symbol to be used as the argument of the type symbol to convey the type of a rational number.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"rational_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","complex_cartesian_type","A symbol to be used as the argument of the type symbol to convey the type of a complex number specified in terms of its real and imaginary parts.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"complex_cartesian_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","complex_polar_type","A symbol to be used as the argument of the type symbol to convey the type of a complex number specified in terms of its modulus and argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"complex_polar_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","constant_type","A symbol to be used as the argument of the type symbol to convey a type for the common constants, pi ~= 3.1415, e ~= 2.718, i = square root of -1, gamma ~= .5772, NaN, infinity (all in the nums cd), true and false (in the logic cd). Also for MathML variables declared to have type constant, as in <ci type=\\\"constant\\\">x</ci>.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"constant_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","vector_type","A symbol to be used as the argument of the type symbol to convey the type of a (column) vector, an n-tuple of entries.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"vector_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","list_type","A symbol to be used as the argument of the type symbol to convey the type for a list.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"list_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","set_type","A symbol to be used as the argument of the type symbol to convey the type for a set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"set_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","matrix_type","A symbol to be used as the argument of the type symbol to convey the type for a matrix (n tuple of rows, where each row is an m tuple for some m, it should be noted that each row must be the same length).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"matrix_type\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("mathmltypes","fn_type","A symbol to be used as the argument of the type symbol to convey the type for a function name.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"mathmltypes\" name=\"type\"></OMS> <OMS cd=\"mathmltypes\" name=\"fn_type\"></OMS> </OMATP> <OMV name=\"f\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("meta",null,"This is a content dictionary to represent content dictionaries, so that they may be passed between OpenMath compliant application in a similar way to mathematical objects. The information written here is taken from chapter 4 of the current draft of the \\\"OpenMath Standard\\\".",new String[] {});
        register_omdef("meta","CD","The top level element for the Content Dictionary. It just acts as a container for the elements described below.",new String[] {});
        register_omdef("meta","CDDefinition","This symbol is used to represent the element which contains the definition of each symbol in a content dictionary. That is: it must contain a \\\'Name\\\' element and a \\\'Description\\\' element, and it may contain an arbitrary number of \\\'Example\\\', \\\'FMP\\\' or \\\'CMP\\\' elements.",new String[] {});
        register_omdef("meta","CDName","An element which contains the string corresponding to the name of the CD. The string must match the syntax for CD names given in the OpenMath Standard. Here and elsewhere white space occurring at the beginning or end of the string will be ignored.",new String[] {});
        register_omdef("meta","CDURL","An optional element. If it is used it contains a string representing the URL where the canonical reference copy of this CD is stored.",new String[] {});
        register_omdef("meta","CDBase","An optional element. If it is used it contains a string representing the URI to be used as the base for generated canonical URI references for symbols in the CD.",new String[] {});
        register_omdef("meta","Example","An element which contains an arbitrary number of children, each of which is either a string or an OpenMath Object. These children give examples in natural language, or in OpenMath, of the enclosing symbol definition.",new String[] {});
        register_omdef("meta","CDDate","An element which contains a date as a string in the ISO-8601 YYYY-MM-DD format. This gives the date at which the Content Dictionary was last edited.",new String[] {});
        register_omdef("meta","CDVersion","An element which contains a version number for the CD. This should be a non negative integer. Any change to the CD that affects existing OpenMath applications that support this CD should result in an increase in the version number.",new String[] {});
        register_omdef("meta","CDRevision","An element which contains a revision number (or minor version number) This should be a non-negative integer starting from zero for each new version. Additional examples would be typical changes to a CD requiring a new revision number.",new String[] {});
        register_omdef("meta","CDReviewDate","An element which contains a date as a string in the ISO-8601 YYYY-MM-DD format. This gives the date at which the Content Dictionary is next scheduled for review. It should be expected to be stable until at least this date.",new String[] {});
        register_omdef("meta","CDStatus","An element giving information on the status of the CD. The content of the element must be one of the following strings. official (approved by the OpenMath Society), experimental (currently being tested), private (used by a private group of OpenMath users), or obsolete (an obsolete CD kept only for archival purposes).",new String[] {});
        register_omdef("meta","CDComment","This symbol is used to represent the element of a content dictionary which explains some aspect of that content dictionary. It should have one string argument which makes that explanation.",new String[] {});
        register_omdef("meta","CDUses","An element which contains zero or more CDNames which correspond to the CDs that this CD depends on, i.e. uses in examples and FMPs. If the CD is dependent on any other CDs they may be present here.",new String[] {});
        register_omdef("meta","Description","An element which contains a string corresponding to the description of either the CD or the symbol (depending on which is the enclosing element).",new String[] {});
        register_omdef("meta","Name","An element containing the string corresponding to the name of the symbol being defined. This must match the syntax for symbol names given in the OpenMath Standard. Here and elsewhere white space occurring at the begining or end of the string will be ignored.",new String[] {});
        register_omdef("meta","Role","An element containing the string corresponding to the role of the symbol being defined.",new String[] {});
        register_omdef("meta","CMP","An optional element (which may be repeated many times) which contains a string corresponding to a property of the symbol being defined.",new String[] {});
        register_omdef("meta","FMP","An optional element which contains an OpenMath Object. This corresponds to a property of the symbol being defined.",new String[] {});
        register_omdef("metagrp",null,"This is a content dictionary to represent Content Dictionary Group Files, so that they may be encoded as OpenMath Objects, which is a possible way of passing this information between OpenMath Applications.",new String[] {});
        register_omdef("metagrp","CDGroupName","This symbol represents the element of a CDGroup which describes the name of that CDGroup, it has one argument that should be a string corresponding to the name. The syntactical requirements are given in the OpenMath standard.",new String[] {});
        register_omdef("metagrp","CDGroupVersion","",new String[] {});
        register_omdef("metagrp","CDGroupURL","This symbol represents the element of a CDGroup which describes the CDGroupURL element. It has one string argument which should describe the URL for that CDGroup, not necessarily for the member Content Dictionaries, The syntactical requirements are given in the OpenMath standard.",new String[] {});
        register_omdef("metagrp","CDGroupDescription","This symbol represents the element of a CDGroup which describes the CDGroupDescription element. It has one string argument, this should be the contents of the CDGroupDescription element intended to describe the mathematical area of the CDGroup.",new String[] {});
        register_omdef("metagrp","CDComment","This symbol is used to represent the element of a CDGroup which explains some aspect of the corresponding content dictionary. It should have one string argument which makes that explanation.",new String[] {});
        register_omdef("metagrp","CDGroupMember","This symbol represents the element of a CDGroup which describes each CDGroupMember element. It has one string argument, this should be the contents of the intended CDGroupMember element of the CDGroup. This should be used to identify each member of the CDGroup.",new String[] {});
        register_omdef("metagrp","CDName","This symbol represents the element of a CDGroup which describes each CDName element. It has one string argument, this should be the string corresponding to the name of a content dictionary which is in this CDGroup.",new String[] {});
        register_omdef("metagrp","CDVersion","This symbol represents the element of a CDGroup which describes each CDVersion element. It has one integral argument, this should specify which version of the content dictionary is to be taken as member of the CDGroup. The element is optional. In case it is missing, the last version is the one included in the CDGroup.",new String[] {});
        register_omdef("metagrp","CDURL","This symbol represents the element of a CDGroup which describes each CDURL element. It has one string argument, this should be the string corresponding to the contents of the CDURL element for each Content Dictionary in the CDGroup. The element is optional, in case it is missing, the location of the CDGroup identified by the element CDGroupURL is assumed.",new String[] {});
        register_omdef("metagrp","CDGroup","This symbol represents the outermost element of a CDGroup. It has an arbitrary number of arguments which may be elements of type corresponding to the other symbols defined in this file.",new String[] {});
        register_omdef("metasig",null,"This is a content dictionary to represent Content Dictionary Signature Files, so that they may be encoded as OpenMath Objects, which is a possible way of passing this information between OpenMath Applications.",new String[] {});
        register_omdef("metasig","CDSignatures","This symbol is used to represent the outermost element of the Signature File which is characterized by two required attributes that identify the type system and the Content Dictionary whose signatures are defined. The value of the XML attribute \\\'type\\\' is the name of the Content Dictionary or of the CDGroup that represents the type system. The value of the XML attribute \\\'cd\\\' is the name of the Content Dictionary whose symbols are assigned signatures in this Signature File. It has an arbitrary number of arguments which may be elements of type corresponding to the other symbols defined in this file.",new String[] {});
        register_omdef("metasig","CDSComment","This symbol is used to represent the element of a signature file which explains some aspect of that signature file. It should have one string argument which makes that explanation.",new String[] {});
        register_omdef("metasig","CDSReviewDate","This symbol is used to represent the element of a signature file which specifies the earliest possible revision date of the signature file. It should have one string argument which specifies that date. The date should be in the format YYYY-MM-DD, e.g. 2000-02-29.",new String[] {});
        register_omdef("metasig","CDSStatus","This symbol is used to represent the element of a signature file which specifies the status of that signature file. It should have one string argument, which should be one of \\\'official\\\' (approved by the OpenMath Society according to the procedure outlined in the OpenMath standard), \\\'experimental\\\' (currently being tested), \\\'private\\\' (used by a private group of OpenMath users) or \\\'obsolete\\\' (an obsolete signature file, kept only for archival purposes).",new String[] {});
        register_omdef("metasig","Signature","This symbol is used to represent the element of a signature file which specifies the signature of a symbol. It should take two string children, the first should be the symbol who\\\'s signature is being specified, the second should be an \\\'OMOBJ\\\' element which specifies the signature. Additionally the second argument should specify an object which must represent a valid type in the type system identified by the XML attribute \\\'type\\\' corresponding to the element which corresponds to the symbol \\\'CDSignatures\\\' enclosing this symbol.",new String[] {});
        register_omdef("minmax1",null,"This CD holds the definitions of min and max.",new String[] {});
        register_omdef("minmax1","min","This symbol denotes the unary minimum function which takes a set as its argument and returns the minimum element in that set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"minmax1\" name=\"min\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 9 </OMI> <OMI> 5 </OMI> </OMA> </OMA> <OMI> 1 </OMI> </OMA> </OMOBJ>"});
        register_omdef("minmax1","max","This symbol denotes the unary maximum function which takes a set as its argument and returns the maximum element in that set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"minmax1\" name=\"max\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 9 </OMI> <OMI> 5 </OMI> </OMA> </OMA> <OMI> 9 </OMI> </OMA> </OMOBJ>"});
        register_omdef("monoid1",null,"Basic functions for monoid theory",new String[] {});
        register_omdef("monoid1","monoid","This symbol is a constructor for monoids. It takes three arguments in the following order: a set to specify the elements in the monoid, a binary operation to specify the monoid operation, and an element to specify the identity. The binary operation should act on elements of the set and return an element of the set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"set1\" name=\"in\"></OMS> <OMA><OMS cd=\"arith1\" name=\"divide\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> </OMA> </OMOBJ>"});
        register_omdef("monoid1","carrier","This symbol represents a unary function, whose argument should be a monoid M (for instance constructed by monoid). When applied to M, its value should be the set of elements of a monoid.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> </OMA> </OMA> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid1","multiplication","This symbol represents a unary function, whose argument should be a monoid M. It returns the multiplication map on M. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"fns2\" name=\"apply_to_list\"></OMS> <OMA><OMA><OMS cd=\"monoid1\" name=\"multiplication\"></OMS> <OMV name=\"M\"></OMV> </OMA> <OMA><OMS cd=\"list3\" name=\"list_of_lengthn\"></OMS> <OMV name=\"n\"></OMV> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("monoid1","identity","This symbols represents a unary function, whose argument should be a monoid. It returns the identity element of the monoid.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"identity\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"e\"></OMV> </OMA> </OMA> <OMV name=\"e\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative monoid.",new String[] {});
        register_omdef("monoid1","is_invertible","This symbol represents a binary function, whose first argument is a monoid M and whose second argument is an element x of M. Its value is true iff the argument if x is invertible (that is, has a left and a right inverse) in M.",new String[] {});
        register_omdef("monoid1","is_submonoid","The binary boolean function whose value is true iff the second argument is a submonoid of the second.",new String[] {});
        register_omdef("monoid1","semigroup","This symbol is a unary function, whose argument should be a monoid M. When applied to M its value is the semigroup underlying M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"semigroup\"></OMS> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid1","submonoid","This symbol is a constructor symbol with two arguments. The first argument is a monoid M, the second a list or set, D, of elements of M. When applied to M and D, it denotes the submonoid of M generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"submonoid\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"D\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"relation1\" name=\"neq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> </OMA> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("monoid1","invertibles","This symbol is a unary function. Its argument should be a monoid M. When applied to M, it denotes the submonoid of M consisting of all invertible elements in M. This is a group.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"invertibles\"></OMS> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid1","divisor_of","This symbol is a ternary function. Its first argument should be a monoid M and the second and third arguments should be elements of M. When applied to M, a, and b, it denotes the fact that a is a divisor of b in M. This means that there are u,v in carrier(M) such that uav=b.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid1\" name=\"divisor_of\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid1","expression","This symbol is a function with two arguments. Its first argument should be a monoid. The second should be an arithmetic expression A, whose operators are times and power, and whose leaves are members of the carrier of G. The second argument of power should be nonnegative. When applied to G and A, it denotes the element (of G) that is obtained from the leaves of A by applying the multiplication and the power map of G instead of the times and power from the CD arith1 appearing in A. The symbol alg1.one occurring in A will be interpreted as the identity of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"expression\"></OMS> <OMA><OMS cd=\"monoid1\" name=\"monoid\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>4</OMI><OMI>3</OMI> </OMA> </OMA> <OMI>7</OMI> </OMA> </OMOBJ>"});
        register_omdef("monoid2",null,"Basic functions for monoid theory",new String[] {});
        register_omdef("monoid2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are monoids M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a monoid homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are monoids M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a monoid isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a monoid M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a monoid endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid2","is_automorphism","This symbol is a boolean function with two arguments. The first is a monoid M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a monoid automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid2","left_multiplication","This symbol is a function with two arguments, which should be a monoid M and an element x of M. When applied to M and x, it denotes left multiplication on M by x.",new String[] {});
        register_omdef("monoid2","right_multiplication","This symbol is a function with two arguments, which should be a monoid M and an element x of M. When applied to M and x, it denotes right multiplication on M by x.",new String[] {});
        register_omdef("monoid2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are monoids. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid3",null,"Monoid constructions",new String[] {});
        register_omdef("monoid3","cyclic_monoid","This symbol is a function of two natural numbers, the first of which should be positive. When evaluated at k and l, it denotes the cyclic monoid with a cycle of length l and a tail (including the identity element) of length k.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"monoid3\" name=\"cyclic_monoid\"></OMS> <OMV name=\"k\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("monoid3","maps_monoid","This is a unary function whose argument must be a set X or a positive integer. When applied to X, it refers to the monoid of all functions from X to X if X is a set and to {1,...,X} if X is an integer, whose binary operation is composition of maps and whose identity element is the identity map on the set X, respectively {1,...,X}.",new String[] {});
        register_omdef("monoid3","left_regular_representation","This is a unary function whose argument must be a monoid M. When applied to M, it represents the map from M to the maps monoid on M that assigns to m left multiplication by m on M.",new String[] {});
        register_omdef("monoid3","automorphism_group","This is a function with a single argument which must be a monoid. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("monoid3","direct_product","This is an n-ary function whose arguments must be monoids. It refers to the direct product of its arguments.",new String[] {});
        register_omdef("monoid3","direct_power","This is a binary function whose first argument should be a monoid M and whose second argument should be a natural number n. It refers to the direct product of n copies of M.",new String[] {});
        register_omdef("monoid3","free_monoid","This symbol represents a unary function. The argument is a list or a set. When evaluated on such an argument, the function represents the free monoid generated by the entries of the list or set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"monoid3\" name=\"free_monoid\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("monoid3","strings","This symbol represents a unary function. The argument is a list or a set. When evaluated on such an argument, the function represents the set of all strings whose characters are entries of the list or set.",new String[] {});
        register_omdef("monoid3","emptyword","This symbol represents a constant. It represents the empty string.",new String[] {});
        register_omdef("monoid3","concatenation","This symbol represents a binary concatenation operation on strings.",new String[] {});
        register_omdef("moreerrors",null,"This symbol represents the error which is returned when an application detects a lexical or syntactic error. It should have one argument which is a string, which should explain the error that occurred.",new String[] {});
        register_omdef("moreerrors","encodingError","This symbol represents the error which is returned when an application detects a lexical or syntactic error. It should have one argument which is a string, which should explain the error that occurred.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"moreerrors\" name=\"encodingError\"></OMS> <OMSTR> The symbol &lt;OMS cd=\'arith1\' name=\'plus\'/&gt; may not take a String as first argument </OMSTR> </OME> </OMOBJ>"});
        register_omdef("moreerrors","algorithm","This symbol represents the error which is returned when an application raises an error due to algorithmic restrictions of the implementations. This includes operations not implemented or partially implemented, divisions by zero and other domain errors. It will have at least one argument, which is a string describing the problem. It may have a second argument which is relevant to the error.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"moreerrors\" name=\"algorithm\"></OMS> <OMSTR> multiplication by $\\sqrt{-1}$ has not been implemented </OMSTR> </OME> </OMOBJ>"});
        register_omdef("moreerrors","limitation","This symbol represents the error which is returned when an application reads an error caused by the limitations of an implementation when dealing with OpenMath objects such as limits on the size of objects or on the kind of objects manipulated. This can include limits on the size of a bytearray or integer, a limit on the number of arguments of an application or the inability to deal with Unicode characters outside ISO latin 1. It will have at least one argument, which is a string describing the problem. It may have a second argument which is relevant to the error.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"moreerrors\" name=\"limitation\"></OMS> <OMSTR> Integers $&gt; 2^{32}-1$ are meaningless to this application </OMSTR> </OME> </OMOBJ>"});
        register_omdef("moreerrors","unexpected","This symbol represents the error which is returned when an application reads an error caused by an unexpected problem. It will have at least one argument, which is a string describing the problem. It may have a second argument which is relevant to the error.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"moreerrors\" name=\"unexpected\"></OMS> <OMSTR> A kill was executed on the process whilst it was evaluating the expression </OMSTR> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>1</OMI><OMI>1</OMI> </OMA> </OME> </OMOBJ>"});
        register_omdef("moreerrors","asynchronousError","This symbol represents the error which is returned when an application encounters some asynchronous error, for example if a limit in memory has been reached, or an error has occurred in some system call (I/O error, disk full, machine down). It should have one argument, which is a string describing the problem.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OME> <OMS cd=\"moreerrors\" name=\"asynchronousError\"></OMS> <OMSTR> A \'disk-full\' error occured </OMSTR> </OME> </OMOBJ>"});
        register_omdef("multiset1",null,"This CD defines the set functions and constructors for basic multiset theory. It is intended to be `compatible\\\' with the corresponding elements in MathML i.e. set operations acting on sets of type=multiset.",new String[] {});
        register_omdef("multiset1","size","This symbol is used to denote the number of elements in a multiset. It is either a non-negative integer, or an infinite cardinal number. The symbol infinity may be used for an unspecified infinite cardinal.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"multiset1\" name=\"size\"></OMS> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 3 </OMI> <OMI> 3 </OMI> <OMI> 9 </OMI> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("multiset1","cartesian_product","This symbol represents an n-ary construction function for constructing the Cartesian product of multisets. It takes n multiset arguments in order to construct their Cartesian product.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"cartesian_product\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("multiset1","emptyset","This symbol is used to represent the empty multiset, that is the multiset which contains no members. It takes no parameters.",new String[] {});
        register_omdef("multiset1","multiset","This symbol represents the multiset construct. It is either an n-ary function, in which case the multiset entries are given explicitly, or it works on an elements construct. There is no implied ordering to the elements of a multiset.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 4 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> <OMI> 1 </OMI> <OMI> 4 </OMI> </OMA> </OMOBJ>"});
        register_omdef("multiset1","intersect","This symbol is used to denote the n-ary intersection of multisets. It takes multisets as arguments, and denotes the multiset that contains all the elements that occur in all of them, with multiplicity the minimum of their multiplicities in all multisets.",new String[] {});
        register_omdef("multiset1","union","This symbol is used to denote the n-ary union of multisets. It takes multisets as arguments, and denotes the multiset that contains all the elements that occur in any of them, with multiplicity the sum of all the multiplicities in the multiset arguments.",new String[] {});
        register_omdef("multiset1","setdiff","This symbol is used to denote the multiset difference of two multisets. It takes two multisets as arguments, and denotes the multiset that contains all the elements that occur in the first multiset with strictly greater multiplicity than in the second. The multiplicity in the result is the difference of the two.",new String[] {});
        register_omdef("multiset1","subset","This symbol has two (multiset) arguments. It is used to denote that the first set is a subset of the second, i.e. every element of the first occurs with multiplicity at least as much in the second.",new String[] {});
        register_omdef("multiset1","in","This symbol has two arguments, an element and a multiset. It is used to denote that the element is in the given multiset.",new String[] {});
        register_omdef("multiset1","notin","This symbol has two arguments, an element and a multiset. It is used to denote that the element is not in the given multiset.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"notin\"></OMS> <OMI> 4 </OMI> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("multiset1","prsubset","This symbol has two (multiset) arguments. It is used to denote that the first multiset is a proper subset of the second, that is a subset of the second multiset but not actually equal to it.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"prsubset\"></OMS> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("multiset1","notsubset","This symbol has two (multiset) arguments. It is used to denote that the first multiset is not a subset of the second.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"notsubset\"></OMS> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("multiset1","notprsubset","This symbol has two (multiset) arguments. It is used to denote that the first multiset is not a proper subset of the second. A proper subset of a multiset is a subset of the multiset but not actually equal to it.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"multiset1\" name=\"notprsubset\"></OMS> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("nums1",null,"This CD is intended to be `compatible\\\' with the MathML view of constructors for numbers (integers to an arbitrary base, rationals) and symbols for some common numerical constants. This CD holds a set of symbols for creating numbers, including some defined constants (i.e. nullary constructors).",new String[] {});
        register_omdef("nums1","based_integer","This symbol represents the constructor function for integers, specifying the base. It takes two arguments, the first is a positive integer to denote the base to which the number is represented, the second argument is a string which contains an optional sign and the digits of the integer, using 0-9a-z (as a consequence of this no radix greater than 35 is supported). Base 16 and base 10 are already covered in the encodings of integers.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMI> 8 </OMI> <OMA> <OMS cd=\"nums1\" name=\"based_integer\"></OMS> <OMI> 8 </OMI> <OMSTR> 10 </OMSTR> </OMA> </OMA></OMOBJ>"});
        register_omdef("nums1","rational","This symbol represents the constructor function for rational numbers. It takes two arguments, the first is an integer p to denote the numerator and the second a nonzero integer q to denote the denominator of the rational p/q.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMA> <OMS cd=\"nums1\" name=\"rational\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA></OMOBJ>"});
        register_omdef("nums1","infinity","A symbol to represent the notion of infinity.",new String[] {});
        register_omdef("nums1","e","This symbol represents the base of the natural logarithm, approximately 2.718. See Abramowitz and Stegun, Handbook of Mathematical Functions, section 4.1.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"approx\"></OMS> <OMF dec=\"2.718\"></OMF> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("nums1","i","This symbol represents the square root of -1.",new String[] {});
        register_omdef("nums1","pi","A symbol to convey the notion of pi, approximately 3.142. The ratio of the circumference of a circle to its diameter.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"approx\"></OMS> <OMF dec=\"3.142\"></OMF> <OMS cd=\"nums1\" name=\"pi\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("nums1","gamma","A symbol to convey the notion of the gamma constant as defined in Abramowitz and Stegun, Handbook of Mathematical Functions, section 6.1.3. It is the limit of 1 + 1/2 + 1/3 + ... + 1/m - ln m as m tends to infinity, this is approximately 0.5772 15664.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"approx\"></OMS> <OMF dec=\"0.577\"></OMF> <OMS cd=\"nums1\" name=\"gamma\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("nums1","NaN","A symbol to convey the notion of not-a-number. The result of an ill-posed floating computation. See IEEE standard for floating point representations.",new String[] {});
        register_omdef("omtypes",null,"Types for OM Declaration of symbols for names of types of OpenMath objects An OpenMath object which uses any of the symbols here defined, has to use them in accordance with their description. Initial version: O. Caprotti",new String[] {});
        register_omdef("omtypes","omtype","The type of symbolic type symtype",new String[] {});
        register_omdef("omtypes","symtype","The type of symbolic types introduced in other CDs",new String[] {});
        register_omdef("omtypes","integer","The type of integers",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR><OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"omtypes\" name=\"integer\"></OMS> </OMATP> <OMI> 0 </OMI> </OMATTR></OMOBJ>"});
        register_omdef("omtypes","float","The type of floating point numbers",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMATTR> <OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"omtypes\" name=\"float\"></OMS> </OMATP> <OMF dec=\"1.0\"></OMF> </OMATTR> </OMOBJ>"});
        register_omdef("omtypes","string","The type of character strings",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMATTR> <OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"omtypes\" name=\"string\"></OMS> </OMATP> <OMSTR> hello world </OMSTR> </OMATTR> </OMOBJ>"});
        register_omdef("omtypes","bytearray","The type of byte arrays",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMATTR> <OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"omtypes\" name=\"bytearray\"></OMS> </OMATP> <OMB>Hkw2Hs3Kd9kjasdk</OMB> </OMATTR> </OMOBJ>"});
        register_omdef("opnode",null,"This CD contains constructors for the operators used to describe the operations corresponding to operation nodes which occur in straight line programs.",new String[] {});
        register_omdef("opnode","plus","A constant value, constructs the plus for addition nodes.",new String[] {});
        register_omdef("opnode","minus","A constant value, constructs the minus for subtraction nodes.",new String[] {});
        register_omdef("opnode","times","A constant value, constructs the times for multiplication nodes.",new String[] {});
        register_omdef("opnode","divide","A constant value, constructs the divide for division nodes.",new String[] {});
        register_omdef("opnode","return","A unary function, takes a node of an slp, returns the value of the polynomial which corresponds to this node of the slp.",new String[] {});
        register_omdef("permgp1",null,"A CD of functions for permutation groups",new String[] {});
        register_omdef("permgp1","group","This symbol represents an n-ary function. The first argument is a group operation (usually, left_compose or right_compose), the other n-1 arguments represent permutations. When evaluated on such arguments, the function represents the permutation group generated by the last n-1 arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","support","This represents a unary function whose argument should be a permutation group. When evaluated at a permutation group G, it is the set of points which are moved a member of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"support\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","generators","This is a function with one argument, which should be a permutation group. When evaluated with argument G it returns the list of permutations which occur in the definition of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"generators\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> <OMI>2</OMI> </OMA> </OMOBJ>"});
        register_omdef("permgp1","orbit","The binary function whose first argument should be a permutation group G. If the second argument is an element of the support of G, the value is the orbit of the second argument under the action of G. Otherwise, it is the singleton consisting of the second argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"orbit\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> <OMI>2</OMI> </OMA> </OMOBJ>"});
        register_omdef("permgp1","stabilizer","This is an n-ary function with n at least 2. The first argument is a permutation group G, the other arguments are elements x_2,x_3,...,x_n upon which G acts. The value is the subgroup of G consisting of all permutations which stabilize each of x_2,x_3,...,x_n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"stabilizer\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMOBJ>"});
        register_omdef("permgp1","is_transitive","This is a Boolean function with one argument, which should be a permutation group. When evaluated at a permutation group G, it returns the value true if and only if the permutation group argument acts transitively on the support of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"is_transitive\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","orbits","This is a function with one argument, which should be a permutation group. When evaluated at a permutation group G, it returns the set of all orbits of G on elements from the support of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"orbits\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","is_primitive","The unary function with one argument, which should be a permutation group. Its value is true if and only if G acts primitively on the support of G. This means that there is no proper subset B of the support of G with more than one element such that the image of B under an element of G meets B in a proper nonempty subset of B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"is_primitive\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI><OMI>3</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","schreier_tree","This is a function with two arguments. The first argument should be a permutation group G, the second argument a point x permuted by G. When evaluated at G and x, it returns a list of three lists X,V,B. The first list, X, enumerates the points of the G-orbit of x. The second list and the third list both have the same length as X, say n. The second list represents a map V from [1,...,n] to {-m,...,-1,0,1,...,m}, where m is the number of generators of G, and the third list represents a map B from [1,...,n] to X. These maps satisfy the following properties: X(1) = B(1) = x. Moreover, V(i) = 0 if and only if i = 1. For each index i distinct from 1, the value B(i) is equal to X(j) for some index j smaller than i. If V(i) is positive, then X(i) is the image of B(i) under the V(i)-th generator of G. If V(i) is negative, then B(i) is the image of X(i) under the (-V(i))-th generator of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"schreier_tree\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI><OMI>3</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> <OMI>4</OMI> </OMA> </OMOBJ>"});
        register_omdef("permgp1","base","This is a function with one argument, which should be a permutation group. When evaluated with argument G it returns a list of points permuted by G such that the stabilizer of all elements of the list in G is trivial. Besides, the list is minimal with respect to the latter property (in the sense that the stabilizer in G of the elements of no proper subset is trivial).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"base\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","order","This is a function with one argument, which should be a permutation group. When evaluated with argument G it returns the size of the group G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"order\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","is_in","This is a Boolean function with two arguments. The first argument should be a permutation, the second a permutation group. When evaluated with first argument x and second argument G, it returns true if and only if x belongs to G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"is_in\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","is_subgroup","This is a Boolean function with two arguments, both of which are permutation groups. When evaluated with first argument H and second argument G it returns true if and only if H is a subgroup of G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"is_subgroup\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI><OMI>3</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI><OMI>2</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp1","stabilizer_chain","This function takes one argument which should be a permutation group. When applied to the permutation group G, its value is a list consisting of two lists B, H of equal length. The first list B is a base for G, whereas the i-th entry H[i] of the second list is the stabilizer in G of the elements B[1], ..., B[i].",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permgp1\" name=\"stabilizer_chain\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>5</OMI><OMI>4</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>6</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>6</OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp2",null,"A CD of functions for permutation groups. Primarily for defining the best known permutation groups.",new String[] {});
        register_omdef("permgp2","symmetric_group","This symbol represents a unary function. Its argument is either a positive integer or a set. When evaluated on a set, it represents the permutation group of all permutations of that set. When evaluated on a positive integer n, it represents the permutation group of all permutations of the set {1,..., n}.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI><OMI>3</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"permgp2\" name=\"symmetric_group\"></OMS> <OMI>3</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp2","alternating_group","This symbol represents a unary function. Its argument is either a positive integer or a set. When evaluated on a set, it represents the permutation group of all even permutations of that set. When evaluated on a positive integer n, it represents the permutation group of all even permutations of the set {1,..., n}.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permgp1\" name=\"group\"></OMS> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>2</OMI><OMI>3</OMI> </OMA> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI><OMI>4</OMI><OMI>5</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"permgp2\" name=\"alternating_group\"></OMS> <OMI>5</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp2","cyclic_group","This symbol represents a unary function whose argument should be a positive integer. When evaluated at the integer n, it represents the permutation group generated by the permutation (1,2,...,n).",new String[] {});
        register_omdef("permgp2","dihedral_group","This symbol represents a unary function whose argument should be a positive integer. When evaluated at the integer n, it represents the dihedral group of all 2n permutations of {1,2,...,n} preserving the n-gon 1,2,...,n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permgp2\" name=\"dihedral_group\"></OMS> <OMI>3</OMI> </OMA> <OMA><OMS cd=\"permgp2\" name=\"symmetric_group\"></OMS> <OMI>3</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permgp2","quaternion_group","This symbol represents the quaternion group of order 8, viewed as a permutation group by means of the regular representation (multiplication from the right). It is generated by (1,2,3,4)(5,8,6,7) and (1,5,2,6)(3,7,4,8). (In the usual notation, the 8 elements are 1, -1, i, -i, j, -j, k, -k.)",new String[] {});
        register_omdef("permgp2","vierer_group","This symbol represents the Klein Vierer group of order 4, viewed as a permutation group of degree 4. It consists of the identity, (1,2)(3,4), (1,3)(2,4), and (1,4)(2,3).",new String[] {});
        register_omdef("permgrp",null,"A CD of functions for permutation groups",new String[] {});
        register_omdef("permgrp","orbit","The binary function whose value is the set of integers which are in the orbit of the second argument under the action of the first argument which is a permutation group.",new String[] {});
        register_omdef("permgrp","stabilizer","The first argument is a permutation group, the second is some object (point or set) upon which the first argument acts. The value is the subgroup of the first argument which stabilize the second argument.",new String[] {});
        register_omdef("permgrp","is_transitive","The unary function whose value is true iff the permutation group argument acts transitively.",new String[] {});
        register_omdef("permgrp","is_primitive","The unary function whose value is true iff its permutation group argument acts primitively.",new String[] {});
        register_omdef("permut1",null,"A CD of functions for permutations",new String[] {});
        register_omdef("permut1","permutation","The n-ary constructor permutation. The arguments are the integers 1 .. n in some order. permutation(p1, ..., pn) is the function which takes 1 to p1, 2 to p2 and so on.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMA> <OMS cd=\"permut1\" name=\"permutation\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 1 </OMI> </OMA> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"permut1\" name=\"permutation\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1",null,"This CD defines permutations with finite support. In order to make available permutations of arbitrary objects, permutations are defined as sets of cycles. The set on which the permutation acts is not specified. To this end, cycles of length 0 or 1 do not occur in permutations. When viewed as the set of cycles which are its arguments, the symbol permutation has a normal form constructor. All symbols defined in this CD may appear as the head of an application. For such symbols, we distinguish between functions and constructors. A function is thought of as a mathematical function, which can be evaluated on its arguments, a constructor uses its arguments as fields of a structure. (In principle, the arguments of a constructor should be accessible; we have not introduced separate symbols to enable access because the `destruction\\\' of the mathematical object can take place in phrasebooks.) The constructors in this CD are cycle, permutation, list_perm, and endomap. The operations inverse, left_compose, right_compose are also defined in this CD, although the most general purpose version already occurs in fns1, fns2. The reasons is two-fold: first, strictly speaking, our permutations are not maps, and so these notions havfe to redefined. A more practical reason is that with dynamical loading, it is easier to encode and decode a new symbol in the CD at hand rather than a symbol in a CD that is previously dealt with. Revision 0.1: fix added; error in support example corrected. Revision 0.2: added endomap. Help of Henny Wilbrink.",new String[] {});
        register_omdef("permutation1","endomap","This symbol is an n-ary constructor. Its arguments should be positive integers. When applied to arguments a_1,...,a_n, the resulting value is the map sending i to a_i for i=1,...,n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI>2</OMI> <OMI>2</OMI> <OMI>1</OMI> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMA> <OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI> 5 </OMI> <OMI> 1 </OMI> <OMI> 3 </OMI> <OMI> 2 </OMI> <OMI> 4 </OMI> </OMA> <OMI> 4 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","list_perm","This symbol is an n-ary constructor. Its arguments should be distinct positive integers in the interval [1,n]. When applied to arguments a_1,...,a_n, the resulting value is the permutation mapping i to a_i for i=1,...,n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"list_perm\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>1</OMI> <OMI>5</OMI> <OMI>4</OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMA> <OMS cd=\"permutation1\" name=\"list_perm\"></OMS> <OMI> 5 </OMI> <OMI> 1 </OMI> <OMI> 3 </OMI> <OMI> 2 </OMI> <OMI> 4 </OMI> </OMA> <OMI> 4 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","is_endomap","This symbol is an n-ary function. Its arguments should be positive integers. When applied to arguments a_1,...,a_n, the resulting value is true if a_i is at most n for all i, otherwise it is false.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"is_endomap\"></OMS> <OMI>1</OMI> <OMI>3</OMI> <OMI>1</OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"is_endomap\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>5</OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","is_list_perm","This symbol is an n-ary function. Its arguments should be positive integers. When applied to arguments a_1,...,a_n, the resulting value is true if a_i is at most n for all i and all a_i are distinct, otherwise it is false.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"is_list_perm\"></OMS> <OMI>1</OMI> <OMI>3</OMI> <OMI>1</OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"is_list_perm\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>5</OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"is_list_perm\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>1</OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","domain","This symbol is a function with one argument which is a endomap. When applied to a endomap whose arguments are a_1,...,a_n, it represents the set {1,...,n}.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"domain\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI>4</OMI> <OMI>3</OMI> <OMI>5</OMI> <OMI>5</OMI> <OMI>5</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","is_bijective","This symbol has one argument which should be a endomap p. It returns true if {a_1,...,a_n}={1,...,n} where a_1,...a_n are the arguments of p and false otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"is_bijective\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI>1</OMI> <OMI>3</OMI> <OMI>2</OMI> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"is_bijective\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>5</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","endomap_left_compose","This symbol is a binary function. Its arguments should be endomaps with identical domain D. When applied to arguments P1 and P2, the resulting value is the endomap which maps x in D to P1(P2(x)).",new String[] {});
        register_omdef("permutation1","endomap_right_compose","This symbol is a binary function. Its arguments should be endomaps with identical domain D. When applied to arguments P1 and P2, the resulting value is the endomap which maps x in D to P2(P1(x)).",new String[] {});
        register_omdef("permutation1","cycle","This symbol is an n-ary constructor. It marks a relation on the set of its arguments a_1, a_2,...,a_n consisting of the pairs (a_i,a_{i+1}) for i=1,...,n-1 and the pair (a_n,a_1). The arguments a_i should all be distinct. The number n is referred to as the length of the cycle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR> <OMSTR>piet</OMSTR> <OMSTR>klaas</OMSTR> </OMA> </OMOBJ>"});
        register_omdef("permutation1","length","This symbol is a function with one argument, which must be a cycle. When applied to cycle(a_1,a_2,...,a_n), it returns the number n. This number is referred to as the length of the cycle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"length\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI> <OMI>4</OMI> <OMI>3</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","permutation","This symbol is an n-ary constructor whose arguments are cycles of length at least 2 with the property that all entries of all cycles are mutually distinct. The permutation symbol constructs a bijective map from the set X of entries of the cycles to X. The map is defined as follows: if E occurs as an entry of a cycle, then the permutation maps E to the entry following E in the same cycle if it exists and to the first entry in the same cycle otherwise. When applied to an element y outside X, the constructed permutation is considered to fix y.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 1 </OMI> <OMI> 5 </OMI> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 6 </OMI> <OMI> 7 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","is_permutation","This symbol is a boolean function with one argument. If the argument is not a set of cycles of length at least 2, the boolean value is false. Otherwise it is true if and only if the cycles are disjoint (that is, all entries of all cycles in the argument are mutually distinct.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"is_permutation\"></OMS> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 5 </OMI> <OMI> 4 </OMI> <OMI> 4 </OMI> <OMI> 2 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","support","This symbol is a function with one argument which is a permutation. When applied to a permutation whose arguments are the cycles A1,...,An, it represents the set A which is the union of the entries of all Ai for i=1,...,n.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"support\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR> <OMI>4</OMI> <OMSTR>klaas</OMSTR> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI> <OMSTR>klaas</OMSTR> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>piet</OMSTR> <OMI>5</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","fix","This symbol is a function with two arguments. The first argument should be a permutation, the second argument a set. When applied to a permutation g and a set X, it represents the subset A of X all points that do not belong to the support of g.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"support\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR> <OMI>4</OMI> <OMSTR>klaas</OMSTR> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>3</OMI> <OMSTR>klaas</OMSTR> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>piet</OMSTR> <OMI>5</OMI> </OMA> </OMA> <OMA><OMS cd=\"set1\" name=\"set\"></OMS> <OMA><OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI>1</OMI> <OMI>5</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","cycles","This symbol has one argument which should be a endomap p. It returns the list of cycles of p.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"permutation1\" name=\"cycles\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"endomap\"></OMS> <OMI>2</OMI> <OMI>3</OMI> <OMI>4</OMI> <OMI>2</OMI> <OMI>5</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","listendomap","This symbol is a function with one argument which is a permutation whose support consists of positive integers. When applied to such a permutation P, it represents the list of length n whose i-th entry is the image of i under P, where n is the maximum of the support of P.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"listendomap\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 1 </OMI> <OMI> 4 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","cycle_type","This symbol is a function with one argument, which is a permutation. When applied to a permutation P, it represents the multiset of lengths of cycles occurring as arguments of P.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle_type\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 4 </OMI> <OMI> 3 </OMI><OMI> 2 </OMI><OMI> 1 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 5 </OMI><OMI> 6 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR><OMSTR>piet</OMSTR> </OMA> </OMA> </OMA> <OMA><OMS cd=\"multiset1\" name=\"multiset\"></OMS> <OMI> 4 </OMI><OMI> 2 </OMI><OMI> 2 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","order","This symbol is a function with one argument which should be a permutation. When applied to a permutation P, it represents the least positive integer n for which composition of n copies of P represents the identity (that is, a permutation with empty support). Note: in this definition of the order, it does not matter whether left_compose or right_compose is being used.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"order\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 4 </OMI> <OMI> 3 </OMI><OMI> 2 </OMI><OMI> 1 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 5 </OMI><OMI> 6 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR><OMSTR>piet</OMSTR> </OMA> </OMA> </OMA> <OMI> 4 </OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","are_distinct","This symbol is an n-ary boolean function. When applied to a_1, ..., a_n, it is true if and only if the arguments are mutually distinct (that is, a_i and a_j are equal only if i=j).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"permutation1\" name=\"are_distinct\"></OMS> <OMI> 1 </OMI> <OMI> 3 </OMI> <OMI> 2 </OMI> <OMI> 3</OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","sign","This symbol is a function with one argument which should be a permutation. When applied to a permutation P, it represents the sign of P, which is equal to -1 if P is an odd permutation and equal to 1 otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"sign\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 4 </OMI> <OMI> 3 </OMI><OMI> 2 </OMI><OMI> 1 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 5 </OMI><OMI> 6 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMSTR>jan</OMSTR><OMSTR>piet</OMSTR> </OMA> </OMA> </OMA> <OMI> -1 </OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","inverse","This symbol is a unary function. Its argument should be a permutation. When applied to argument P, the resulting value is the inverse permutation of P.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"fns1\" name=\"inverse\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>3</OMI> <OMI>2</OMI> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>4</OMI> <OMI>5</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","left_compose","This symbol is a binary function. Its arguments should be permutations. When applied to arguments P1 and P2, the resulting value is the permutation which maps x in Support(P1) union Support(P2) to P1(P2(x)).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"left_compose\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>2</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>2</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","right_compose","This symbol is a binary function. Its arguments should be permutations. When applied to arguments P1 and P2, the resulting value is the permutation which maps x in Support(P1) union Support(P2) to P2(P1(x)).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"right_compose\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>2</OMI> </OMA> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>2</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("permutation1","action","This symbols is a binary function whose first argument is a permutation (or a endomap) and whose second argument is a point. When applied to permutation or endomap p and point x, it represents the image of the point x under the permutation p.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"action\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI> 5 </OMI><OMI> 4 </OMI> </OMA> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI> 6 </OMI> <OMI> 7 </OMI> </OMA> </OMA> <OMI>1</OMI> </OMA> <OMI>5</OMI> </OMA> </OMOBJ>"});
        register_omdef("permutation1","permutationsn","This symbol is a unary function. Its argument should be a positive integer. When applied to argument n, the resulting value is the set of all permutations of the set {1,..., n}.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"permutation1\" name=\"permutationsn\"></OMS> <OMI>2</OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> </OMA> <OMA><OMS cd=\"permutation1\" name=\"permutation\"></OMS> <OMA><OMS cd=\"permutation1\" name=\"cycle\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("physical_consts1",null,"This CD defines symbols which represent some elementary physical constants.",new String[] {});
        register_omdef("physical_consts1","absolute_zero","This symbol represents the absolute zero of temperature, synonymous with the object of that temperature having zero latent heat.",new String[] {});
        register_omdef("physical_consts1","zero_Celsius","This symbol represents the zero of the Celsius temperature scale.",new String[] {});
        register_omdef("physical_consts1","zero_Fahrenheit","This symbol represents the zero of the Fahrenheit temperature scale.",new String[] {});
        register_omdef("physical_consts1","light_year","This symbol represents the distant for which a beam of light would take a year to traverse, in a vacuum.",new String[] {});
        register_omdef("physical_consts1","speed_of_light","This symbol represents the speed of light in a vacuum. It is approximately 299792458 metres per second.",new String[] {});
        register_omdef("physical_consts1","Planck_constant","This symbol represents the fundamental constant equal to the ratio of the energy of a quantum of energy to its frequency. It is approximately equal to 6.6260755*10^(-34) +/- 4.0*10^(-40) Joule seconds.",new String[] {});
        register_omdef("physical_consts1","mole","This symbol represents the number of atoms in one gramme of carbon(12).",new String[] {});
        register_omdef("physical_consts1","gravitational_constant","This symbol represents the constant of proportionality in Newtons law of universal gravitation which states; Two bodies attract each other with equal and opposite forces; the magnitude of this force is proportional to the product of the two masses and is also proportional to the inverse square of the distance between the centers of mass of the two bodies. It is approximately equal to: 6.672*10^(-11) Newton square metres per kilogramme squared.",new String[] {});
        register_omdef("physical_consts1","Avogadros_constant","This symbol represents the number of atoms in 12 grammes of pure carbon(12). It is approximately 6.0221367*10^(23) +/- 3.6*10^(17).",new String[] {});
        register_omdef("physical_consts1","Faradays_constant","This symbol represents the electric charge carried by one mole of electrons. It is approximately 96485.309 +/- 0.029 Coulombs per mole.",new String[] {});
        register_omdef("physical_consts1","gas_constant","This symbol represents the constant which is equal to the ratio of the pressure times the volume and the temperature of an ideal gas. It is approximately 8.31451 +/- 7.0*10^(-05) Joules per mole per Kelvin.",new String[] {});
        register_omdef("physical_consts1","Loschmidt_constant","This symbol represents the number of particles per unit volume of an ideal gas at standard temperature and pressure. It is approximately 2.686763 * 10^(25) +/- 2.3 * 10^(20) per metre cubed.",new String[] {});
        register_omdef("physical_consts1","magnetic_constant","This symbol represents the ratio of the magnetic flux density in a substance to the external field strength for vacuum. It is equal to 4 pi x 10^(-7) H/m.",new String[] {});
        register_omdef("physical_consts1","Boltzmann_constant","A constant which describes the relationship between temperature and kinetic energy for molecules in an ideal gas. It is approximately 1.380658*10^(-23) +/- 1.2*10^(-28) Joules per Kelvin.",new String[] {});
        register_omdef("piece1",null,"This CD is intended to be compatible with the corresponding elements in Content MathML 2. In this CD we give a set of operators for piece-wise defined expressions.",new String[] {});
        register_omdef("piece1","piecewise","This operator heads an expression that is being defined piecewise. Its arguments are n objects built with the piece constructor, optionally followed by one built with otherwise constructor.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"abs\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA><OMS cd=\"piece1\" name=\"piecewise\"></OMS> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMA><OMS cd=\"arith1\" name=\"unary_minus\"></OMS><OMV name=\"x\"></OMV></OMA> <OMA><OMS cd=\"relation1\" name=\"lt\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMI> 0 </OMI> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"otherwise\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("piece1","piece","This introduces an individual component of a piecewise definition. It has precisely two arguments: the first is the value, and the second is a Boolean (meant to be a predicate) which is true if and only if this piece is to provide the value of the piecewise construct.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"abs\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA><OMS cd=\"piece1\" name=\"piecewise\"></OMS> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMA><OMS cd=\"arith1\" name=\"unary_minus\"></OMS><OMV name=\"x\"></OMV></OMA> <OMA><OMS cd=\"relation1\" name=\"lt\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMI> 0 </OMI> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"otherwise\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("piece1","otherwise","This symbol introduces the \\\'default\\\' value of a piecewise construct. If none of the previous piece constructs can provide the value, this will. It has a single child, the value.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"abs\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA><OMS cd=\"piece1\" name=\"piecewise\"></OMS> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMA><OMS cd=\"arith1\" name=\"unary_minus\"></OMS><OMV name=\"x\"></OMV></OMA> <OMA><OMS cd=\"relation1\" name=\"lt\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"piece\"></OMS> <OMI> 0 </OMI> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS><OMV name=\"x\"></OMV> <OMI> 0 </OMI></OMA> </OMA> <OMA><OMS cd=\"piece1\" name=\"otherwise\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo1",null,"This CD defines symbols for planar Euclidean geometry.",new String[] {});
        register_omdef("plangeo1","point","The symbol is used to indicate a point of planar Euclidean geometry by a variable. The point may (but need not) be subject to constraints. The symbol takes the variable as the first argument and the constraints as further arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"m\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo1","line","The symbol is used to indicate a line of planar Euclidean geometry by a variable. The line may (but need not) be subject to constraints. The symbol takes the variable as the first argument and the constraints as further arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"l\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo1","incident","The symbol represents the logical incidence function which is a binary function taking arguments representing geometric objects like points and lines and returning a boolean value. It is true if and only if the first argument is incident to the second.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo1","configuration","The symbol represents a configuration in Euclidean planar geometry consisting of a sequence of geometric objects like points, lines, etc, but also of other configurations.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"l\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"l\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> <OMA> <OMS cd=\"logic1\" name=\"not\"></OMS> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"c\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"C\"></OMV> <OMA> <OMS cd=\"logic1\" name=\"not\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"C\"></OMV> <OMV name=\"c\"></OMV> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"a\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"B\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"b\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo1","type","The symbol represents the type of the basic geometric objects: points, lines, configuration.",new String[] {});
        register_omdef("plangeo1","assertion","The symbol is a constructor with two arguments. Its first argument should be a configuration, its second argument a statement about the configuration, called thesis. When applied to a configuration C and a thesis T, the OpenMath object assertion(C,T) expresses the assertion that T holds in C.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"plangeo1\" name=\"assertion\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"l\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"m\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"m\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"m\"></OMV> </OMA> <OMA><OMS cd=\"logic1\" name=\"not\"></OMS> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"l\"></OMV> <OMV name=\"m\"></OMV> </OMA> </OMA> </OMA> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo1","are_on_line","The statement that a set of points is collinear.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"are_on_line\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> <OMV name=\"D\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo2",null,"This CD defines symbols for planar Euclidean geometry.",new String[] {});
        register_omdef("plangeo2","segment","The segment of a line between two points of the line. The segment is contained in the affine part of the line. The symbol takes as arguments the two points.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo2\" name=\"segment\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo2","halfline","The halfline starting at A and going through B. The symbol takes as arguments the points A and B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo2\" name=\"halfline\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo2","corner","The corner between two halflines L and M, both starting at the same point. Given three points A, B and C, the corner A, B, C is the corner of the two halflines BA and BC. Corresponding to the two cases, the symbol can have as arguments two halflines or three points.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo2\" name=\"corner\"></OMS> <OMV name=\"L\"></OMV> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo2","endpoint","The endpoint of a halfline.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo2\" name=\"endpoint\"></OMS> <OMV name=\"H\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo2","endpoints","The two endpoints of a segment.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo2\" name=\"endpoints\"></OMS> <OMV name=\"S\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3",null,"This CD defines symbols for planar Euclidean geometry related to distance.",new String[] {});
        register_omdef("plangeo3","distance","The distance between two affine points is the Euclidean distance. The distance between two geometric objects O and O\\\' is the infimum of the distances between two affine points, one on O and one on O\\\'.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"distance\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","perpendicular","perpendicular is a binary boolean function with input two lines, halflines or segments. Its value is true whenever the two inputs are perpendicular to each other.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"perpendicular\"></OMS> <OMV name=\"L\"></OMV> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","parallel","parallel is a binary boolean function with input two lines, halflines or segments. Its value is true whenever the two inputs are parallel.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"parallel\"></OMS> <OMV name=\"L\"></OMV> <OMV name=\"M\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","circle","The symbol represents a circle. The circle may be subject to constraints.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"circle\"></OMS> <OMV name=\"C\"></OMV> <OMA> <OMS cd=\"plangeo3\" name=\"center\"></OMS> <OMV name=\"C\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo3\" name=\"radius\"></OMS> <OMV name=\"C\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","radius","The radius of a circle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"radius\"></OMS> <OMV name=\"C\"></OMV> <OMI>1</OMI> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","radius_of","Gives the radius of a circle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"radius_of\"></OMS> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","center","Defines the center of a circle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"circle\"></OMS> <OMV name=\"C\"></OMV> <OMA> <OMS cd=\"plangeo3\" name=\"center\"></OMS> <OMV name=\"C\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo3\" name=\"radius\"></OMS> <OMV name=\"C\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","center_of","Gives the center of the circle",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"center_of\"></OMS> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","are_on_circle","The statement that a set of points is on one circle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"are_on_circle\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> <OMV name=\"D\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","angle","Angle of a corner, always measured in positive (anti-clockwise) direction.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"angle\"></OMS> <OMA> <OMS cd=\"plangeo2\" name=\"corner\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","midpoint","The midpoint between two points or two endpoints of a segment.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"midpoint\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","is_midpoint","The statement that one point is the midpoint of two others.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"is_midpoint\"></OMS> <OMV name=\"C\"></OMV> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","center_of_gravity","Center of gravity of a number of points.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"G\"></OMV> <OMA> <OMS cd=\"plangeo3\" name=\"center_of_gravity\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","perpbisector","Given two distinct points A and B, this is the line of all points at equal distance to both A and B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"perpbisector\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","altitude","Given a point p and a line L, this defines the segment starting at p and ending in the unique point of L closest to p.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"altitude\"></OMS> <OMV name=\"p\"></OMV> <OMV name=\"L\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","perpline","Given a point p and a line L, this defines the line through p perpendicular to L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"perpline\"></OMS> <OMV name=\"p\"></OMV> <OMV name=\"L\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","polarline","Given a point p and a circle C this defines the polar line of p with respect to C.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"polarline\"></OMS> <OMV name=\"p\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","tangent","Given a line L and a circle C this boolean checks whether L is a tangent line to C.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"tangent\"></OMS> <OMV name=\"L\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo3","arc","an arc of a circle M from A to B is the set of points of M that are encountered when traversing the circle clockwise from A to B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo3\" name=\"arc\"></OMS> <OMA> <OMS cd=\"plangeo3\" name=\"circle\"></OMS> <OMV name=\"M\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo4",null,"This CD defines symbols for planar Euclidean geometry. In particular, it is concerned with projective and affine coordinates of points and lines.",new String[] {});
        register_omdef("plangeo4","set_coordinates","This symbol defines the coordinates of a point or a line. The coordinates are the projective coordinates and consist of a vector of length 3. Points whose third coordinates are zero are the points at infinity. The line whose first two coordinates are zero is the line at infinity.",new String[] {});
        register_omdef("plangeo4","coordinates","This function yields the coordinates vector if applied to a point or line with coordinates.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo4\" name=\"coordinates\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"plangeo4\" name=\"set_coordinates\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>2</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo4","is_affine","Boolean function testing whether a point or line is affine.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo4\" name=\"is_affine\"></OMS> <OMV name=\"A\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("plangeo4","affine_coordinates","This function yields the affine coordinates vector if applied to a point or line with coordinates in the affine plane.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo4\" name=\"affine_coordinates\"></OMS> <OMA> <OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"plangeo4\" name=\"set_coordinates\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>2</OMI> <OMI>3</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo4","set_affine_coordinates","Defines the affine coordinates of an affine point or line.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"A\"></OMV> <OMA> <OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMA> <OMS cd=\"nums1\" name=\"rational\"></OMS> <OMI> 1 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"nums1\" name=\"rational\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo5",null,"This CD contains symbols for generating polynomial systems from affine planar geometry configurations.",new String[] {});
        register_omdef("plangeo5","coordinatize","This symbol is a function of one argument which must be a configuration or an assertion (as defined in plangeo1). When applied to a configuration C, it stands for the same configuration but now with coordinates attached to each object of C. The new variables are bound within an OMBIND element with head element the lambda symbol. The bound variables (placed within an OMBVAR element) are the new variables, and the last argument of OMBIND is the expression C in which each object is coordinatized. If an object already has coordinates, these are left as they are. If not, then new variables are introduced to coordinatize the object. When applied to an assertion of the form assertion(C,S), it leads to the same result except that the last argument of OMBIND is the assertion whose configuration argument is the expression C in which each object is coordinatized, and whose thesis argument is S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"plangeo5\" name=\"coordinatize\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"c\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"c\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>1</OMI> <OMI>1</OMI> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"C\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"C\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>0</OMI> <OMI>1</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"a\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"B\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"b\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"plangeo5\" name=\"coordinatize\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"assertion\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"l\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"l\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"m\"></OMV> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"m\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"m\"></OMV> </OMA> <OMA><OMS cd=\"logic1\" name=\"not\"></OMS> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"l\"></OMV> <OMV name=\"m\"></OMV> </OMA> </OMA> </OMA> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo5","is_coordinatized","This symbol is a boolean valued function of one argument which must be a configuration. When applied to an argument C, it represent the value true if C is a configuration such that each object occurring in C (as well as in its subconfigurations) has coordinates (that is, the set_affine_coordinates field is present as an argument to the object), and value false otherwise. If an object already has coordinates, these are left as they are. If not, then new variables are introduced to coordinatize the object.",new String[] {});
        register_omdef("plangeo5","ideal","This symbol is a function in one argument, which should be a coordinatized configuration (that is, each geometric object involved has coordinates). When evaluated at a configuration C it represents a function (given by a lambda binder) mapping the new parameters (arising when the inequality properties in the configuration are being translated into polynomials) to a list of polynomials in the coordinates that are variables which, when equated to zero, represent conditions equivalent to those describing the configuration C. When evaluated at an assertion assertion(C,S) it represents a function (given by a lambda binder) mapping the new parameters (arising when the inequality properties in the configuration are being translated into polynomials) to a list of polynomials in the coordinates that are variables which, when equated to zero, represent conditions equivalent to those describing the configuration C.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"plangeo5\" name=\"ideal\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"configuration\"></OMS> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"A\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"A\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMV name=\"xA\"></OMV> <OMV name=\"yA\"></OMV> </OMA> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"B\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"B\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMV name=\"xB\"></OMV> <OMV name=\"yB\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"logic1\" name=\"not\"></OMS> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"B\"></OMV> <OMV name=\"A\"></OMV> </OMA> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"c\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_coordinates\"></OMS> <OMV name=\"c\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>1</OMI> <OMI>1</OMI> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"c\"></OMV> <OMV name=\"B\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"point\"></OMS> <OMV name=\"C\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_affine_coordinates\"></OMS> <OMV name=\"C\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMI>1</OMI> <OMI>0</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"a\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_coordinates\"></OMS> <OMV name=\"a\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMV name=\"xa\"></OMV><OMV name=\"ya\"></OMV><OMV name=\"za\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"B\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"line\"></OMS> <OMV name=\"b\"></OMV> <OMA><OMS cd=\"plangeo4\" name=\"set_coordinates\"></OMS> <OMV name=\"b\"></OMV> <OMA><OMS cd=\"linalg2\" name=\"vector\"></OMS> <OMV name=\"xb\"></OMV><OMV name=\"yb\"></OMV><OMV name=\"zb\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA><OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo5","polynomial_assertion","This symbol is a function in one argument, which should be an assertion whose configuration is coordinatized (that is, each geometric object involved has coordinates). When evaluated at an assertion assertion(C,T) it represents the assertion that the constant polynomial 1 belongs to the ideal of the polynomial ring over a coefficient ring R containing the rationals and all global (unbound) coordinates of C, in the bound variables of ideal(C) and an external variable t, generated by ideal(C)[bound variables] and 1-f_T t. Here f_T is a polynomial such that f_T=0 is equivalent to the thesis T being true. This means f_T is in the radical ideal of ideal(C)[bound variables]. The interpretation is as follows: There are no parameter choices for the bound variables such that f_T is nonzero. In other words, for all parameter choices of a coordinatization of C, we must have f_T=0. So the truth of the assertion that thesis T holds in configuration C is reflected by the truth of polynomial_assertion(C,T).",new String[] {});
        register_omdef("plangeo6",null,"This CD defines symbols for planar Euclidean geometry related to conics. amc: 18 March 2004 added are_on_conic",new String[] {});
        register_omdef("plangeo6","conic","The symbol represents a conic. The conic may be subject to constraints.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"plangeo6\" name=\"conic\"></OMS> <OMV name=\"G\"></OMV> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"A\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"B\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"C\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"D\"></OMV> </OMA> <OMA> <OMS cd=\"plangeo1\" name=\"incident\"></OMS> <OMV name=\"G\"></OMV> <OMV name=\"E\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("plangeo6","are_on_conic","The symbol is a boolean n-ary function. Its arguments should be points. When applied to a sequence of points, its evaluated to true if and only if there is a conic on which all arguments lie.",new String[] {});
        register_omdef("poly",null,"This CD contains generic operators to deal with various forms of polynomials. The arithmetic operators from arith1 etc. are valid on these polynomials: there is also the operator \\\"power\\\" from this CD, which creates formal powers. More specific operations for Distributed Multivariate Polynomials can be found in polyd.ocd, and for Recursive polynomials in polyr.ocd.",new String[] {});
        register_omdef("poly","power","Takes a polynomial and a (non-negative) integer and produces a formal power. Although OpenMath does not specify operational semantics, the idea here is that these powers are not evaluated. We note that the power from arith1 would suggest the expanded form.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("poly","factored","The constructor for a factorization. Its arguments are formal powers (see previous operator), where the polynomials are supposed to be irreducible (except possibly for a content from the ground ring). Note that \\\"factored\\\" is not a call to factorise something, rather a statement that we know a factorisation.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"poly\" name=\"factored\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","squarefreed","The constructor for a square-free factorization. Its arguments should have the structure of the above \\\"factored\\\", where the polynomials should be square-free. Note that this is not necessarily a minimal square-free decomposition: some exponents can occur more than once. Again, this is a statement that we have a square-free factorisation, rather than a request to compute one.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"poly\" name=\"squarefreed\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 4 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","partially_factored","The constructor for a factorization. Its arguments are formal powers (see operator above), where nothing in particular is assumed about the polynomials (they may or may not be irreducible, or relatively prime).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"poly\" name=\"partially_factored\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMA> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","expand","Converts a factored or squarefreed form into the expanded polynomial over the same ring, so that factored(recursive) -> recursive, etc.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"poly\" name=\"expand\"></OMS> <OMA> <OMS cd=\"poly\" name=\"factored\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> -4 </OMI> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","degree","The total degree of its argument. The value returned is a non-negative integer. We note that the degree of 0 is undefined. Note that this operation takes no account of any weights that have been defined: see weighted_degree in polyd.",new String[] {});
        register_omdef("poly","degree_wrt","The degree with respect to a variable (the second argument). We note that the degree of 0 is undefined.",new String[] {});
        register_omdef("poly","leading_coefficient","The leading coefficient with respect to a variable (the second argument). We note that the leading coefficient of 0 is undefined.",new String[] {});
        register_omdef("poly","coefficient","The coefficient with respect to a list of variables (the second argument) raised to a list of powers (the third argument). Zero if no such term is present. Not all variables need be specified.",new String[] {});
        register_omdef("poly","coefficient_ring","The coefficient ring.",new String[] {});
        register_omdef("poly","evaluate","Evaluation of a polynomial at a value or vector of values.",new String[] {});
        register_omdef("poly","factor","The decomposition of its argument into irreducible factors. A program that can compute the factorization is required to return a \\\"factored\\\" object - see above. It is currently an open question whether powers of 1 can be omitted.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"poly\" name=\"factor\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> -4 </OMI> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"poly\" name=\"factored\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","squarefree","The square-free decomposition of its argument. A program that can compute the factorization is required to return a \\\"squarefreed\\\" object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"poly\" name=\"squarefree\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> -4 </OMI> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"poly\" name=\"squarefreed\"></OMS> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"poly\" name=\"power\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMI> 4 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("poly","gcd","The n-ary greatest common divisor of its polynomial arguments. This is unique up to units.",new String[] {});
        register_omdef("poly","lcm","The least common multiple of its polynomial arguments. This is unique up to units, but the choice must be compatible with that made for gcd: see the CMP/FMP.",new String[] {});
        register_omdef("poly","discriminant","Function taking two arguments, it represents the discriminant of a polynomial, which is the first argument, with respect to the given variable which is the second argument.",new String[] {});
        register_omdef("poly","resultant","Function taking three arguments, it represents the resultant of two polynomials, which are the first two arguments, with respect to the given variable which is the third argument.",new String[] {});
        register_omdef("poly","convert","Conversion between polynomial rings. The first argument is a polynomial and the second is a polynomial ring. This represents the conversion of the given polynomial as an element of the given ring. A program that can compute the conversion is required to return a polynomial in the given ring.",new String[] {});
        register_omdef("polyd",null,"This CD contains operators to deal with polynomials and more precisely Distributed Multivariate Polynomials.",new String[] {});
        register_omdef("polyd","DMP","The constructor of DMPs. The first argument is the polynomial ring containing the polynomial and the second is a \\\"SDMP\\\". Should be of the form DMP(PolyRingD(...), SDMP(...))",new String[] {});
        register_omdef("polyd","DMPL","The constructor for lists of multivariate polynomial members of the same polynomial ring. The first argument is a polynomial ring and the rest are \\\"SDMP\\\"s. DMPL can be attributed with the \\\"ordering\\\" symbol to indicate a particular ordering for monomials of all its polynomials. Should be of the form DMPL(PolyRingD(...), SDMP(...)+)",new String[] {});
        register_omdef("polyd","SDMP","The constructor for multivariate polynomials without any indication of variables or domain for the coefficients. Its arguments are just \\\"term\\\"s. No terms should differ only by the coefficient (i.e it is not permitted to have both \\\"2*x*y\\\" and \\\"x*y\\\" as terms in a SDMP). SDMP can be attributed with the \\\"ordering\\\" symbol to indicate a particular ordering of its terms. This attribute shall not be set if the SDMP is part of DMPL that has this attribute set. If the SDMP is ordered, explicitly or implicitly via an outer ordering, the terms must be in decreasing order with respect to this order. The zero polynomial is represented by an SDMP with no terms.",new String[] {});
        register_omdef("polyd","term","The constructor of terms. Valid applications are of the form Term(coeff, exp1, exp2, ... expn) which represents the term coeff * var1^exp1*...varn^expn where n is the number of variables, expi are non-negative integers. coeff should be non-zero.",new String[] {});
        register_omdef("polyd","poly_ring_d","The constructor of polynomial ring. The first argument is a ring (the ring of the coefficients), the second is the number of variables as an integer.",new String[] {});
        register_omdef("polyd","poly_ring_d_named","The constructor of polynomial ring. The first argument is a ring (the ring of the coefficients), the remaining arguments are the names of the variables. The first variable given is the most important from the point of view of lexicographic ordering, then the second, and so on.",new String[] {});
        register_omdef("polyd","anonymous","Indicates a variable that we do not want to name",new String[] {});
        register_omdef("polyd","ordering","Used as an attribute to indicate an ordering of the terms in a polynomial or list of polynomials. The value of this attribute should be one of the constructors specifying ordering.",new String[] {});
        register_omdef("polyd","lexicographic","The lexicographic ordering of terms. Note that, if a poly_ring_d_named is used, lexigographic refers to the order of the variables in the poly_ring_d_named, not to their order as strings.",new String[] {});
        register_omdef("polyd","reverse_lexicographic","The reverse lexicographic ordering of terms. Note that, if a poly_ring_d_named is used, lexigographic refers to the order of the variables in the poly_ring_d_named, not to their order as strings.",new String[] {});
        register_omdef("polyd","graded_lexicographic","Total degree order, graded with the lexicographic ordering. Note that, if a poly_ring_d_named is used, lexigographic refers to the order of the variables in the poly_ring_d_named, not to their order as strings.",new String[] {});
        register_omdef("polyd","graded_reverse_lexicographic","Total degree order, graded with the reverse lexicographic ordering. Note that, if a poly_ring_d_named is used, lexigographic refers to the order of the variables in the poly_ring_d_named, not to their order as strings.",new String[] {});
        register_omdef("polyd","elimination","This is an ordering, which is partially in terms of one ordering, and partially in terms of another. First argument is a number of variables. Second is ordering to apply on the first so many variables. Third is an ordering on the rest, to be used to break ties.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyd\" name=\"elimination\"></OMS> <OMI> 1 </OMI> <OMS cd=\"polyd\" name=\"lexicographic\"></OMS> <OMS cd=\"polyd\" name=\"graded_reverse_lexicographic\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("polyd","matrix_ordering","The argument is a matrix with as many columns as indeterminates (= rank). Each row in turm is multiplied by the column vector of exponents to produce a weighting for comparison purposes.",new String[] {});
        register_omdef("polyd","weighted","The first argument is a list of integers to act as variable weights, and the second is an ordering. The result is an ordering.",new String[] {});
        register_omdef("polyd","weighted_degree","The total degree of its argument, taking into account any weights declared. The value returned is an integer: non-negative if the weights are. We note that the degree of 0 is undefined.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"polyd\" name=\"weighted_degree\"></OMS> <OMA> <OMS cd=\"polyd\" name=\"DMP\"></OMS> <OMA> <OMS cd=\"polyd\" name=\"poly_ring_d\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMI> 3 </OMI> </OMA> <OMATTR> <OMATP> <OMS cd=\"polyd\" name=\"ordering\"></OMS> <OMA> <OMS cd=\"polyd\" name=\"weighted\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMS cd=\"polyd\" name=\"graded_lexicographic\"></OMS> </OMA> </OMATP> <OMA> <OMS cd=\"polyd\" name=\"SDMP\"></OMS> <OMA> <OMS cd=\"polyd\" name=\"term\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"polyd\" name=\"term\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"polyd\" name=\"term\"></OMS> <OMI> 3 </OMI> <OMI> 0 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"polyd\" name=\"term\"></OMS> <OMI> 4 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> </OMA> </OMA> </OMATTR> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("polyd","groebnered","The constructor for a Groebner basis (reduced, minimal). The first argument is an ordering, the second is the Groebner Basis itself (with respect to the ordering) that should be represented as a DMPL.",new String[] {});
        register_omdef("polyd","completely_reduced","This attribute, attached to a groebnered object, says \\\'true\\\' if the base is fully reduced, i.e. no monomial is divisible by the leading monomial of any other polynomial.",new String[] {});
        register_omdef("polyd","plus","The sum. The argument is a DMPL. The sum lies within the same \\\"PolyRingD\\\" i.e. a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\" (or \\\"poly_ring_d_named\\\").",new String[] {});
        register_omdef("polyd","times","The product. The argument is a DMPL. The product lies within the same \\\"PolyRingD\\\" i.e. a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\" (or \\\"poly_ring_d_named\\\").",new String[] {});
        register_omdef("polyd","power","The power. First argument is a DMP, second argument is the integer power. The power lies within the same \\\"PolyRingD\\\" i.e. a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\" (or \\\"poly_ring_d_named\\\").",new String[] {});
        register_omdef("polyd","groebner","The groebner basis (lt-reduced, minimal) of a set of polynomials, with respect to a given ordering. First argument is an ordering, the second is a list of polynomials. A program that can compute the basis is required to return a \\\"groebnered\\\" object.",new String[] {});
        register_omdef("polyd","reduce","The reduction of a polynomial with respect to a Groebner basis. First argument is a DMP, the second argument is a \\\"groebnered\\\" object. i.e. a program implementing this operation should return a DMP which represents the polynomial reduced with respect to the Groebner basis.",new String[] {});
        register_omdef("polyd1",null,"This CD contains operators to deal with polynomials and more precisely Distributed Multivariate Polynomials.",new String[] {});
        register_omdef("polyd1","DMP","The constructor of DMPs. The first argument is the polynomial ring containing the polynomial and the second is a \\\"SDMP\\\". Should be of the form DMP(poly_ring_d(...), SDMP(...))",new String[] {});
        register_omdef("polyd1","ambient_ring","This is a unary function, whose argument should be a DMP f. When applied to f, it represents the first argument of f, that is, ring of the form poly_ring_d(...) used to define f.",new String[] {});
        register_omdef("polyd1","rank","This is a unary function, whose argument can be a DMP, a poly_ring_d, or a poly_ring_d_named. When applied to its argument, it represents the number of variables of the polynomial ring involved.",new String[] {});
        register_omdef("polyd1","variables","This is a unary function, whose argument is a poly_ring_d_named. When applied to its argument, it represents the list of variables of the polynomial ring.",new String[] {});
        register_omdef("polyd1","DMPL","The constructor for lists of multivariate polynomial members of the same polynomial ring. The first argument is a polynomial ring and the rest are \\\"SDMP\\\"s. DMPL can be attributed with the \\\"ordering\\\" symbol to indicate a particular ordering for monomials of all its polynomials. Should be of the form DMPL(poly_ring_d(...), SDMP(...)+)",new String[] {});
        register_omdef("polyd1","SDMP","The constructor for multivariate polynomials without any indication of variables or domain for the coefficients. Its arguments are just \\\"monomial\\\"s. No monomials should differ only by the coefficient (i.e it is not permitted to have both \\\"2*x*y\\\" and \\\"x*y\\\" as monomials in a SDMP). SDMP can be attributed with the \\\"ordering\\\" symbol to indicate a particular ordering of its monomials. This attribute shall not be set if the SDMP is part of DMPL that has this attribute set.",new String[] {});
        register_omdef("polyd1","term","The constructor of monomials. Valid applications are of the form Term(coeff, exp1, exp2, ... expn) which represents the monomial coeff * var1^exp1*...varn^expn where n is the number of variables, expi are non-negative integers.",new String[] {});
        register_omdef("polyd1","poly_ring_d","The constructor of polynomial ring. The first argument is a ring (the ring of the coefficients), the second is the number of variables as an integer.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polyd1\" name=\"poly_ring_d\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMI>2</OMI> </OMA> </OMOBJ>"});
        register_omdef("polyd1","poly_ring_d_named","The constructor of polynomial ring. The first argument is a ring (the ring of the coefficients), the remaining arguments are the names of the variables. The first variable given is the most important from the point of view of lexicographic ordering, then the second, and so on.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"poly_ring_d_named\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"X\"></OMV> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"X\"></OMV><OMV name=\"b\"></OMV> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyd1","anonymous","Indicates a variable that we do not want to name",new String[] {});
        register_omdef("polyd1","plus","The sum. The argument is a DMPL. The sum lies within the same \\\"poly_ring_d\\\", i.e., a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\".",new String[] {});
        register_omdef("polyd1","minus","The sum. The argument is a DMPL. The sum lies within the same \\\"poly_ring_d\\\", i.e., a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\".",new String[] {});
        register_omdef("polyd1","times","The product. The argument is a DMPL. The product lies within the same \\\"poly_ring_d\\\", i.e., a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\".",new String[] {});
        register_omdef("polyd1","power","The power. First argument is a DMP, second argument is the integer power. The power lies within the same \\\"poly_ring_d\\\", i.e., a program implementing this operation should return a DMP with the same \\\"poly_ring_d\\\".",new String[] {});
        register_omdef("polyd2",null,"This CD defines symbols for ordering of monomial for Distributed Multivariate Polynomials, which were defined in polyd1.",new String[] {});
        register_omdef("polyd2","ordering","Used as an attribute to indicate an ordering of the monomials in a polynomial or list of polynomials. The value of this attribute should be one of the constructors specifying ordering.",new String[] {});
        register_omdef("polyd2","lexicographic","The lexicographic ordering of monomials.",new String[] {});
        register_omdef("polyd2","reverse_lexicographic","The reverse lexicographic ordering of monomials",new String[] {});
        register_omdef("polyd2","graded_lexicographic","Total degree order, graded with the lexicographic ordering.",new String[] {});
        register_omdef("polyd2","graded_reverse_lexicographic","Total degree order, graded with the reverse lexicographic ordering.",new String[] {});
        register_omdef("polyd2","elimination","This is an ordering, which is partially in terms of one ordering, and partially in terms of another. First argument is a number of variables. Second is ordering to apply on the first so many variables. Third is an ordering on the rest, to be used to break ties.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polyd2\" name=\"elimination\"></OMS> <OMI> 1 </OMI> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> <OMS cd=\"polyd2\" name=\"graded_reverse_lexicographic\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("polyd2","matrix_ordering","The argument is a matrix with as many columns as indeterminates (= rank). Each row in turm is multiplied by the column vector of exponents to produce a weighting for comparison purposes.",new String[] {});
        register_omdef("polyd2","weighted","The first argument is a list of integers to act as variable weights, and the second is an ordering. The result is an ordering.",new String[] {});
        register_omdef("polyd2","weighted_degree","The total degree of its argument, taking into account any weights declared. The value returned is an integer: non-negative if the weights are. We note that the degree of 0 is undefined.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"polyd2\" name=\"weighted_degree\"></OMS> <OMA> <OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMA> <OMS cd=\"polyd1\" name=\"poly_ring_d\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMI> 3 </OMI> </OMA> <OMATTR> <OMATP> <OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMA> <OMS cd=\"polyd2\" name=\"weighted\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMS cd=\"polyd2\" name=\"graded_lexicographic\"></OMS> </OMA> </OMATP> <OMA> <OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA> <OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI> 1 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI> 3 </OMI> <OMI> 0 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> </OMA> <OMA> <OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI> 4 </OMI> <OMI> 1 </OMI> <OMI> 0 </OMI> <OMI> 0 </OMI> </OMA> </OMA> </OMATTR> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("polyd3",null,"This CD contains conversions between different data structures for polynomials.",new String[] {});
        register_omdef("polyd3","collect","This a binary function. Its first argument should be a DMP f, its second argument a list of positive integers L. When applied to f and L, it represents the DMP with coefficients from the poly_ring_d whose variables only have indices i for i not occurring in the list L, and whose monomials are built up from the variables indexed by the entries of L.",new String[] {});
        register_omdef("polyd3","list_to_poly_d","This symbol is a function with two arguments. The first argument is a ring R and the second argument is a list L. The entries of L are elements of R or can be cast canconically onto elements of R. When applied to R and L, the symbol denotes the distributed (univariate) polynomial over R with terms (L[i-1],i) for i running over the indices of L (i=1, ..., length(L)).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polyd3\" name=\"list_to_poly_d\"></OMS> <OMS cd=\"ringname1\" name=\"Z\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>7</OMI><OMI>4</OMI><OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyd3","poly_d_to_arith","This symbol is a binary function. The first argument is a DMP and the second argument is a list of objects, typically variables or arithmetic expressions, at least as many as there are variables in the ring to which the DMP belongs. When applied to R and L, the symbol denotes the arithmetic expression that is the sum of the terms with the i-th variable of the ring of the DMP being substituted by the i-th expression or variable of the list L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polyd3\" name=\"poly_d_to_arith\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"poly_ring_d\"></OMS> <OMS cd=\"ringname1\" name=\"Z\"></OMS> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>7</OMI><OMI>0</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>4</OMI><OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"X\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyd3","poly_d_named_to_arith","This symbol is a unary function. Its argument is a DMP with named variables. When applied to R, the symbol denotes the arithmetic expression that is the sum of the terms.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polyd3\" name=\"poly_d_to_arith\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"DMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"poly_ring_d_named\"></OMS> <OMS cd=\"ringname1\" name=\"Z\"></OMS> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"polyd1\" name=\"SDMP\"></OMS> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>7</OMI><OMI>0</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>4</OMI><OMI>1</OMI> </OMA> <OMA><OMS cd=\"polyd1\" name=\"term\"></OMS> <OMI>1</OMI><OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb",null,"This CD contains operators for Groebner basis computations with polynomial expressions. It is derived from surgery of polyd.",new String[] {});
        register_omdef("polygb","groebner_basis","The constructor for a Groebner basis (reduced, minimal). The first is a list of variables, the second argument is an ordering, the third is the Groebner Basis itself (with respect to the ordering) that should be represented as a polynomial expression.",new String[] {});
        register_omdef("polygb","groebner","The groebner basis (reduced, minimal) of a set of polynomials, with respect to a given ordering. First argument is a list of variables, the second is an ordering, the third is a list of polynomials. A program that can compute the basis is required to return a \\\"groebner_basis\\\" object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polygb1\" name=\"groebner\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb","groebnered","The constructor for a Groebner basis (reduced, minimal). The first argument is an ordering, the second is the Groebner Basis itself (with respect to the ordering) that should be represented as a DMPL.",new String[] {});
        register_omdef("polygb","completely_reduced","This attribute, attached to a groebnered object, says \\\'true\\\' if the base is fully reduced, i.e. no monomial is divisible by the leading monomial of any other polynomial.",new String[] {});
        register_omdef("polygb","reduce","The reduction of a polynomial with respect to a list P of polynomials. First argument is a polynomial expression p, the second argument is the list P of polynomials, the third argument is a list of variables, the fourth argument is a monomial reduction ordering. A program implementing this operation should return a polynomial which represents a polynomial reduced from p with respect to P. This means that p is expressible as the sum of the returned polynomial and a linear combination of the polynomials from P with coefficients being polynomials in the variables given in the third argument, and that no monomial of the returned polynomial is divisible by the leading monomial of an element from P.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polygb1\" name=\"reduce\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI>3</OMI> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMI>3</OMI> </OMA> <OMI>-1</OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV><OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb2",null,"This CD contains operators for Groebner basis computations with polynomial expressions. It adds features to polygb1 like testing membership of an ideal, and of the radical ideal of an ideal, and providing insight as to how to change the ideal minimally so as to let this happen. Suggestion: polygb3 is to contain a trace of the GB computation. polygb4 is to contain S poly",new String[] {});
        register_omdef("polygb2","in","This symbol is a function of at least 4 arguments. The first argument is a polynomial p, the second is a list of variables, the third is an ordering the fourth is a list of polynomials B, and, optionally, the fifth is a polynomial_ring. When applied to its arguments, it represents the boolean value of the assertion that p belongs to the ideal generated by B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"set1\" name=\"in\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb2","in_radical","This symbol is a function of at least 4 arguments. The first argument should be a polynomial p, the second is a list of variables, the third is an ordering the fourth is a list of polynomials B, and optionally: the fifth is a polynomial_ring. When applied to its arguments, it represents the boolean value of the assertion that p belongs to the radical ideal generated by B.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polygb2\" name=\"in_radical\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> <OMI> 2 </OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb2","minimal_groebner_element","This symbol is a function with 3 arguments. First argument is a list of variables, the second is an ordering, the third is a list B of polynomials. [Optionally, the fourth is a polynomial ring.] When applied to its arguments, it represents the polynomial in the Groebner basis of B with respect to the ordering with the least leading monomial.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"polygb2\" name=\"minimal_groebner_element\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA><OMS cd=\"polyd2\" name=\"ordering\"></OMS> <OMS cd=\"polyd2\" name=\"lexicographic\"></OMS> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"y\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> <OMI> 2 </OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMI> 2 </OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polygb2","extended_in","This symbol is a function of at least 3 arguments. The first argument is a list of variables. The second and third argument are lists of polynomials in the variables from the first argument, C and T respectively. When applied to its arguments, it represents the boolean value of the assertion that all elements t in T can be written as t = f_1*c_1 + ... + f_n*c_n (c_i in C). If the optional 4th argument is 1, those f_i are returned.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polygb2\" name=\"extended_in\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> 2 </OMI> <OMV name=\"y\"></OMV> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"y\"></OMV> </OMA> <OMI> 1 </OMI> </OMA> </OMOBJ>"});
        register_omdef("polynomial1",null,"This CD holds a collection of basic constructs for univariate polynomials over rings. The data structures for polynomials can be arithmetic expressions, for instance using the ring1.expression symbol, or DMP as in the CD polyd1.",new String[] {});
        register_omdef("polynomial1","coefficient_ring","This symbol is a unary function whose argument should be a polynomial. It represents the coefficient ring of the polynomial.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"polynomial1\" name=\"coefficient_ring\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMA><OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI>7</OMI> </OMA> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"X\"></OMV><OMI>1</OMI> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> <OMA><OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI>7</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polynomial1","coefficient","This symbol is a binary function whose first argument should be a polynomial f and whose second argument should be a non-negative integer n. It represents the coefficient of the i-th power of the variable in the polynomial f.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"polynomial1\" name=\"coefficient\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMA><OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI>7</OMI> </OMA> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"X\"></OMV><OMI>1</OMI> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI>7</OMI> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polynomial1","expand","Expands a polynomial.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"polynomial1\" name=\"expand\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMA><OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI>7</OMI> </OMA> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"X\"></OMV><OMI>1</OMI> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polynomial1","degree","This symbol represents a unary function, whose argument should be univariate polynomial. When applied to a polynomial, it represents its degree, that is the highest power of the variable occurring in a term of the polynomial. If the polynomial has no terms, it is the zero polynomial, in which case the value represented is -1.",new String[] {});
        register_omdef("polynomial1","leading_term","This symbol represents a unary function, whose argument should be univariate polynomial. When applied to a polynomial, it represents its leading term, that is the term that is the product of the highest power of the variable and its coefficient. If the polynomial is zero, the value represented is zero.",new String[] {});
        register_omdef("polynomial1","leading_coefficient","This symbol represents a unary function, whose argument should be univariate polynomial. When applied to a polynomial, it represents the coefficient of the monomial of highest degree. If the polynomial is zero, the value represented is zero.",new String[] {});
        register_omdef("polynomial1","leading_monomial","This symbol represents a unary function, whose argument should be a nonzero univariate polynomial. When applied to such a polynomial, it represents the highest power of the variable occurring in the polynomial.",new String[] {});
        register_omdef("polynomial2",null,"This CD holds a collection of basic modular arithmetic for univariate polynomials over rings. The data structures for polynomials can be arithmetic expressions, for instance using the ring1.expression symbol, or DMP as in the CD polyd1.",new String[] {});
        register_omdef("polynomial2","modulo_relation","This symbol represents a univariate function, whose argument should be a polynomial. When applied to a polynomial m, it denotes the equivalence relation of being equal modulo m.",new String[] {});
        register_omdef("polynomial2","divides","This symbol represents a bivariate Boolean function, whose arguments should be polynomials in the same polynomial ring. When applied to a and b, it denotes the property that a divides b.",new String[] {});
        register_omdef("polynomial2","eqmod","This symbol represents a Boolean valued trivariate function, whose arguments should be polynomials. When applied to polynomials a, b, m, it denotes the Boolean evalue of the assertion that a and b are equal modulo m.",new String[] {});
        register_omdef("polynomial2","neqmod","This symbol represents a Boolean valued trivariate function, whose arguments should be polynomials. When applied to polynomials a, b, m, it denotes the Boolean evalue of the assertion that a and b are not equal modulo m.",new String[] {});
        register_omdef("polynomial2","class","This symbol represents a bivariate function, whose arguments should be polynomials. If a, m are polynomials in a polynomial ring R[X], then class(a,m) denotes the residue class a mod m in the quotient ring R[X]/ (mR[X]).",new String[] {});
        register_omdef("polynomial3",null,"This CD holds a collection of basic modular arithmetic for polynomials over fields. The data structures for polynomials can be arithmetic expressions, for instance using the ring1.expression symbol, or DMP as in the CD polyd1.",new String[] {});
        register_omdef("polynomial3","gcd","The n-ary greatest common divisor for univariate polynomials over fields.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polynomial3\" name=\"gcd\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"Y\"></OMV> <OMV name=\"Z\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polynomial3","factors","This symbol is a unary function, whose argument should be a polynomial f. When applied to f, it represents a complete list of irreducible factors of f.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA><OMS cd=\"polynomial3\" name=\"factors\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMV name=\"X\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"X\"></OMV><OMI>2</OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>2</OMI><OMV name=\"X\"></OMV> </OMA> <OMI>1</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polynomial3","quotient","This symbol represents the binary division operator on univariate polynomials over fields. That is, for univariate polynomials a and b, quotient(a,b) denotes the polynomial q such that a=b*q+r, with degree(r) less than degree(b).",new String[] {});
        register_omdef("polynomial3","remainder","The symbol represents a binary function, whose arguments should be univariate polynomials in the same polynomial ring whose coefficient ring is a field. When applied to a and b, it represents the polynomial remainder after division of a by b.",new String[] {});
        register_omdef("polyoperators1",null,"We define several polynomial operators.",new String[] {});
        register_omdef("polyoperators1","gcd","The n-ary greatest common divisor for univariate polynomials.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polyoperators1\" name=\"gcd\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"Y\"></OMV> <OMV name=\"Z\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polyoperators1","factor","The action of factoring a polynomial into irreducible factors (I know this is field dependent but lets keep it simple by now).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polyoperators1\" name=\"factor\"></OMS> <OMV name=\"X\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polyoperators1","factors","The action of returning a list composed of the irreducible factors of a polynomial. (I know this is field dependent but lets keep it simple by now).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"polyoperators1\" name=\"factors\"></OMS> <OMV name=\"X\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polyoperators1","expand","Expands a polynomial. Acts as expand(expresion).",new String[] {});
        register_omdef("polyr",null,"This CD contains operators to deal with polynomials and more precisely Recursive Polynomials. Note that polynomials are regarded as univariates in their most significant variable (as defined by the order in PolynomialRingR: the first variable to appear is the most significant), with monomials in decreasing order of exponent, and coefficients being polynomials in the rest of the variables. This means that polynomials have a unique representation, except for the fact that yz \\\\in Z[x,y,z] could also be represented as x^0yz. This latter is discouraged, but currently not expressly forbidden.",new String[] {});
        register_omdef("polyr","term","A constructor for monomials, that is products of powers and elements of the base ring. First argument is from N (the exponent of the variable implied by an outer poly_r_rep) second argument is a coefficient (from the ground field, or a polynomial in lesser variables).",new String[] {});
        register_omdef("polyr","poly_r_rep","A constructor for the representation of polynomials. The first argument is the polynomial variable, the rest are monomials (in decreasing order of exponent).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 2 </OMI> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"y\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 6 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 0 </OMI> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"y\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 5 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyr","polynomial_r","The constructor of Recursive Polynomials. The first argument is the polynomial ring containing the polynomial and the second is a \\\"poly_r_rep\\\".",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyr\" name=\"polynomial_r\"></OMS> <OMA> <OMS cd=\"polyr\" name=\"polynomial_ring_r\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 2 </OMI> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"y\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 6 </OMI> <OMI> 1 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 0 </OMI> <OMA> <OMS cd=\"polyr\" name=\"poly_r_rep\"></OMS> <OMV name=\"y\"></OMV> <OMA> <OMS cd=\"polyr\" name=\"term\"></OMS> <OMI> 5 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyr","polynomial_ring_r","The constructor of a recursive polynomial ring. The first argument is a ring (the ring of the coefficients), the rest are the variables (in order).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyr\" name=\"polynomial_ring_r\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polyslp",null,"This CD contains operators to deal with polynomials and more precisely polynomials held in Straight Line Program representation.",new String[] {});
        register_omdef("polyslp","polynomial_SLP","The constructor of Polynomials built with Straight Line Program representation. The first argument is the polynomial ring containing the polynomial built with poly_ring_SLP, The second argument is the program body built with prog_body.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyslp\" name=\"polynomial_SLP\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"poly_ring_SLP\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"prog_body\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"inp_node\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"inp_node\"></OMS> <OMV name=\"y\"></OMV> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"op_node\"></OMS> <OMS cd=\"opnode\" name=\"times\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"op_node\"></OMS> <OMS cd=\"opnode\" name=\"times\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"opnode\" name=\"return\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"op_node\"></OMS> <OMS cd=\"opnode\" name=\"plus\"></OMS> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyslp","prog_body","The constructor of the body of the straight line program the arguments represent straight line instructions, as constructed by the following three constructors, op_node, inp_node and const_node, possibly wrapped in the return symbol (from the opnode CD). The order is taken to be the order in which they appear.",new String[] {});
        register_omdef("polyslp","op_node","This constructor takes three arguments. The first argument is a symbol from opnode, meant to specify whether the node is a plus, minus times or divide node, the second and third arguments are integers, which are the numbers of the lines which are the arguments of the operation",new String[] {});
        register_omdef("polyslp","inp_node","This constructor takes one argument, which is a variable. The return value is intended to represent an input node.",new String[] {});
        register_omdef("polyslp","const_node","This constructor takes one argument, which is a value from the coefficient ring. It is intended to represent a constant node.",new String[] {});
        register_omdef("polyslp","length","A unary function taking an slp as argument and returning the length of this slp.",new String[] {});
        register_omdef("polyslp","depth","A unary function taking an slp as argument and returning the greatest depth of any leaf node, that is the length of the longest contiguous path to any leaf node.",new String[] {});
        register_omdef("polyslp","slp_degree","A unary function taking an slp as argument and returning the apparent multiplicative degree of the slp, without performing any cancellation.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"polynomial_SLP\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"poly_ring_SLP\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"prog_body\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"inp_node\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA> <OMS cd=\"polyslp\" name=\"op_node\"></OMS> <OMS cd=\"opnode\" name=\"times\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"opnode\" name=\"return\"></OMS> <OMA> <OMS cd=\"polyslp\" name=\"op_node\"></OMS> <OMS cd=\"opnode\" name=\"minus\"></OMS> <OMI> 2 </OMI> <OMI> 2 </OMI> </OMA> </OMA> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("polyslp","return_node","Takes an slp as the argument, and returns the return node of the slp.",new String[] {});
        register_omdef("polyslp","node_selector","Takes an slp as the first argument, the second argument is the position of the required node. Returns the node of the slp at this position.",new String[] {});
        register_omdef("polyslp","left_ref","Takes as argument a node of an slp. Returns the value of the left hand pointer of the node.",new String[] {});
        register_omdef("polyslp","right_ref","Takes as argument a node of an slp. Returns the value of the right hand pointer of the node.",new String[] {});
        register_omdef("polyslp","quotient","A quotient function for polynomials represented by slps. It is a requirement that this is an exact division.",new String[] {});
        register_omdef("polyslp","monte_carlo_eq","This is a Monte-Carlo equality test, it takes three arguments, the first two are slps representing polynomials, the third argument is the maximum probability of incorrectness that is required of the equality test. (Monte-Carlo equality tests are very important for slps as they offer the only tractable method of solving the equality problem in many cases)",new String[] {});
        register_omdef("polyslp","poly_ring_SLP","The constructor of the polynomial ring. The first argument is a ring, (the ring of the coefficients), the rest are the variables, in any order.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyslp\" name=\"poly_ring_SLP\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("polysts",null,"This CD holds the polynomial symbols used by the OpenMath Small Type System. PolynomialRing is the equivalent of an Axiom category, whereas PolynomialRingD and PolynomialRingR are functors returning elements of that category, polynomial rings with a specific representation (at the abstract OMtree level)",new String[] {});
        register_omdef("polysts","polynomial_ring","The type of all polynomial rings, e.g. from polyr or polyd OCDs",new String[] {});
        register_omdef("polyu",null,"This CD contains operators to deal with polynomials and more precisely Univariate Polynomials. Note that recursive polynomials are regarded as univariates in their most significant variable (as defined by the order in PolynomialRingR: the first variable to appear is the most significant), with monomials in decreasing order of exponent, and coefficients being polynomials in the rest of the variables, and therefore univariates are a special case. This is provided as a separate CD to allow for univariate-only operations (e.g. composition) and for systems that only understand univariates, e.g. NTL.",new String[] {});
        register_omdef("polyu","term","A constructor for monomials, that is products of powers and elements of the base ring. First argument is from N (the exponent of the variable implied by an outer poly_u_rep) second argument is a coefficient (from the ground field)",new String[] {});
        register_omdef("polyu","poly_u_rep","A constructor for the representation of polynomials. The first argument is the polynomial variable, the rest are monomials (in decreasing order of exponent).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyu\" name=\"poly_u_rep\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 6 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 5 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 0 </OMI> <OMI> 2 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyu","polynomial_u","The constructor of Recursive Polynomials. The first argument is the polynomial ring containing the polynomial and the second is a \\\"poly_u_rep\\\".",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyu\" name=\"polynomial_u\"></OMS> <OMA> <OMS cd=\"polyu\" name=\"polynomial_ring_u\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> </OMA> <OMA> <OMS cd=\"polyu\" name=\"poly_u_rep\"></OMS> <OMV name=\"x\"></OMV> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 6 </OMI> <OMI> 1 </OMI> </OMA> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 5 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"polyu\" name=\"term\"></OMS> <OMI> 0 </OMI> <OMI> 2 </OMI> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("polyu","polynomial_ring_u","The constructor of a univariate polynomial ring. The first argument is a ring (the ring of the coefficients), the second is the variable.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"polyu\" name=\"polynomial_ring_u\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("prog1",null,"A CD for basic algorithmic concepts. We define the minimal machinery to write small programs in OpenMath encoding.",new String[] {});
        register_omdef("prog1","assignment","This symbol is used to assign values to variables. The syntax is assignment(variable, value), where variable is the encoding of an OpenMath variable (OMV) and value is an OpenMath object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"a\"></OMV> <OMI> 125 </OMI> </OMA> </OMOBJ>"});
        register_omdef("prog1","block","This symbol is meant to represent an arbitray block of code. A block of code can be empty. The syntax is block(obj1, obj2,...,objN), where obji is the OpenMath encoding of the ith sentence (or action) inside the body.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"a\"></OMV> <OMI> 153 </OMI> </OMA> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"a\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("prog1","local_var","This symbol can be used to declare local variables.",new String[] {});
        register_omdef("prog1","global_var","This symbol can be used to declare global variables as know to function.",new String[] {});
        register_omdef("prog1","return","This symbol can be used to return values from fuctions.",new String[] {});
        register_omdef("prog1","for","This symbol can be used to encode the for loop. The syntax is for(block1,conditional_block,block3,block4), where block1 is the inicialization block, conditional_block is the conditional block that determines the end of the loop, block3 is the incremental block and block4 is the body of the for loop. Each of this blocks should be present (althougth they can be empty).",new String[] {});
        register_omdef("prog1","while","The symbol the while loop. The syntax is while(conditional_block, block1), where conditional_block is the block that determines when to stop the while loop and block1 is the body of the while loop.",new String[] {});
        register_omdef("prog1","if","The symbol can be used to encode the if, then, else construct. The syntax is if(conditional_block,block1,block2), where the conditional_block is the block that determines wich of the block of codes block1 and block2 is going to be executed, block1 is the then block and block2 if the else block. The conditional_block and block1 are required but block2 is optional.",new String[] {});
        register_omdef("prog1","call_arguments","This symbol can be used to encode the arguments that will be pased to a function or procedure.",new String[] {});
        register_omdef("prog1","def_arguments","This symbol can be used to encode the arguments that a function or procedure can receive.",new String[] {});
        register_omdef("prog1","function_block","The block of code defining the body of the function. The syntax is function_block(local_var,block1), where local_var encodes the local variables (private to the function body) and block1 is the body of the function. Both locar_var and block1 should be present (and of course both can be also empty).",new String[] {});
        register_omdef("prog1","function_definition","The symbol function_definition can be is used to define a function. The syntax is function_definition(name, def_arguments, function_block), where name is the encoding of an OpenMath variable (OMV) representing the name of the funtion, def_arguments is the enconding of the arguments that the function receives and function_block is the body of the function (local variables declarations + body of the function). Functions are completely unaware of the rest of the \\\"world\\\" except for the information they received from the arguments. Functions are only allowed to return values by means of the return construct.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"function_definition\"></OMS> <OMV name=\"MyFunct\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"def_arguments\"></OMS> <OMV name=\"N\"></OMV> </OMA> <OMA> <OMS cd=\"prog1\" name=\"function_block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"local_var\"></OMS> <OMV name=\"i\"></OMV> <OMV name=\"Result\"></OMV> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"Result\"></OMV> <OMI>1</OMI> </OMA> <OMA> <OMS cd=\"prog1\" name=\"for\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"i\"></OMV> <OMI>2</OMI> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"relation1\" name=\"leq\"></OMS> <OMV name=\"i\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"i\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"i\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"Result\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"i\"></OMV> <OMI> 10 </OMI> </OMA> <OMI>1</OMI> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"return\"></OMS> <OMV name=\"Result\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"function_definition\"></OMS> <OMV name=\"Prog1AddCubes\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"def_arguments\"></OMS> <OMV name=\"n\"></OMV> </OMA> <OMA> <OMS cd=\"prog1\" name=\"function_block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"local_var\"></OMS> <OMV name=\"Total\"></OMV> <OMV name=\"i\"></OMV> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"i\"></OMV> <OMI>1</OMI> </OMA> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"Total\"></OMV> <OMI>0</OMI> </OMA> <OMA> <OMS cd=\"prog1\" name=\"while\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"relation1\" name=\"leq\"></OMS> <OMV name=\"i\"></OMV> <OMV name=\"n\"></OMV> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"Total\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"Total\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"i\"></OMV> <OMI>3</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"assignment\"></OMS> <OMV name=\"i\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"i\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"return\"></OMS> <OMV name=\"Total\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"function_definition\"></OMS> <OMV name=\"Prog1Fibonacci\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"def_arguments\"></OMS> <OMV name=\"n\"></OMV> </OMA> <OMA> <OMS cd=\"prog1\" name=\"function_block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"local_var\"></OMS> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"if\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"logic1\" name=\"or\"></OMS> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"n\"></OMV> <OMI>1</OMI> </OMA> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMV name=\"n\"></OMV> <OMI>2</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"return\"></OMS> <OMI>1</OMI> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"block\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"return\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"prog1\" name=\"function_call\"></OMS> <OMV name=\"Prog1Fibonacci\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"call_arguments\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"n\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"prog1\" name=\"function_call\"></OMS> <OMV name=\"Prog1Fibonacci\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"call_arguments\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMV name=\"n\"></OMV> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("prog1","function_call","Symbol function_call can be used to \\\"call\\\" already defined functions. The syntax is function_call(name, call_arguments), where name is the encoding of an OpenMath variable (OMV) representing the name of the function and call_arguments are the arguments to pass to the function. Both, name and call_arguments, should be present but call_arguments can be empty.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA> <OMS cd=\"prog1\" name=\"function_call\"></OMS> <OMV name=\"MyFunct\"></OMV> <OMA> <OMS cd=\"prog1\" name=\"call_arguments\"></OMS> <OMI>100</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("prog1","procedure_definition","This symbol can be used to define a procedure. The sintax is procedure_definition(name, def_arguments, procedure_block), where name is the encoding of an OpenMath variable representing the name of the procedure, def_arguments encodes the argument the procedure can receive and procedure_block encodes the body of the procedure. Contrary to function procedures can have knowledge about global objects by means of the global_var construct (see procedure block).",new String[] {});
        register_omdef("prog1","procedure_call","Symbol procedure_call can be used to \\\"call\\\" already defined procedures. The syntax is procedure_call(name, call_arguments), where name is the encoding of an OpenMath variable (OMV) representing the name of the function and call_arguments are the arguments to pass to the function. Both, name and call_arguments, should be present but call_arguments can be empty.",new String[] {});
        register_omdef("prog1","procedure_block","The block of code defining the body of the procedure. The syntax is procedure_block(local_var, global_var, block1), where local_var encodes the local variables (private to the procedure body), gloval_var are global variables that are know to the procedure and block1 is the body of the procedure. All these elements, locar_var, global_var and block1, should be present (but they can also be empty).",new String[] {});
        register_omdef("quant1",null,"This CD holds the definitions of the basic universal (\\\"for all\\\") quantifier and existential (\\\"there exists\\\") quantifier. It is intended to be `compatible\\\' with the MathML elements representing these quantifiers.",new String[] {});
        register_omdef("quant1","forall","This symbol represents the universal (\\\"for all\\\") quantifier which takes two arguments. It must be placed within an OMBIND element. The first argument is the bound variables (placed within an OMBVAR element), and the second is an expression.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMBIND> <OMS cd=\"quant1\" name=\"forall\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"logic1\" name=\"implies\"></OMS> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"setname1\" name=\"R\"></OMS> </OMA> <OMA> <OMS cd=\"relation1\" name=\"leq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"abs\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"sin\"></OMS> <OMV name=\"x\"></OMV> </OMA> </OMA> <OMF dec=\"1.0\"></OMF> </OMA> </OMA> </OMBIND> </OMOBJ>"});
        register_omdef("quant1","exists","This symbol represents the existential (\\\"there exists\\\") quantifier which takes two arguments. It must be placed within an OMBIND element. The first argument is the bound variables (placed within an OMBVAR element), and the second is an expression.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"logic1\" name=\"not\"></OMS> <OMBIND> <OMS cd=\"quant1\" name=\"exists\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> <OMV name=\"z\"></OMV> <OMV name=\"n\"></OMV> </OMBVAR> <OMA> <OMS cd=\"logic1\" name=\"and\"></OMS> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"y\"></OMV> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"z\"></OMV> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMV name=\"n\"></OMV> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> <OMA> <OMS cd=\"relation1\" name=\"gt\"></OMS> <OMV name=\"n\"></OMV> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"n\"></OMV> </OMA> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"y\"></OMV> <OMV name=\"n\"></OMV> </OMA> </OMA> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"z\"></OMV> <OMV name=\"n\"></OMV> </OMA> </OMA> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("relation0",null,"Binary relations properties, equivalence relation, orders, up to the definition of a setoid as a set with an equivalence relations defined on its elements. Initial version: O. Caprotti",new String[] {});
        register_omdef("relation0","relation","Type constructor; returns the type of binary relations on a set.",new String[] {});
        register_omdef("relation0","reflexive","Proposition; the type of reflexive binary relations.",new String[] {});
        register_omdef("relation0","irreflexive","Proposition; the type of irreflexive binary relations.",new String[] {});
        register_omdef("relation0","transitive","Proposition; the type of transitive binary relations.",new String[] {});
        register_omdef("relation0","symmetric","Proposition; the type of symmetric binary relations.",new String[] {});
        register_omdef("relation0","antisymmetric","Proposition; the type of antisymmetric binary relations.",new String[] {});
        register_omdef("relation0","partial_equivalence","Proposition; the type of partial_equivalence relations, namely relations that are symmetric, and transitive.",new String[] {});
        register_omdef("relation0","equivalence","Proposition; the type of equivalence relations, namely relations that are reflexive, symmetric and transitive.",new String[] {});
        register_omdef("relation0","order","Proposition; the type of order relations, namely relations that are reflexive, antisymmetric and transitive.",new String[] {});
        register_omdef("relation0","strict_order","Proposition; the type of strict order relations, namely relations that are irreflexive, antisymmetric and transitive.",new String[] {});
        register_omdef("relation0","pre_order","Proposition; the type of preorder relations, namely relations that are reflexive and transitive.",new String[] {});
        register_omdef("relation1",null,"This CD holds the common arithmetic relations. It is intended to be `compatible\\\' with the appropriate MathML elements.",new String[] {});
        register_omdef("relation1","eq","This symbol represents the binary equality function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","lt","This symbol represents the binary less than function which returns true if the first argument is less than the second, it returns false otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"lt\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 4 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","gt","This symbol represents the binary greater than function which returns true if the first argument is greater than the second, it returns false otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"gt\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","neq","This symbol represents the binary inequality function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"neq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","leq","This symbol represents the binary less than or equal to function which returns true if the first argument is less than or equal to the second, it returns false otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"leq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 4 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","geq","This symbol represents the binary greater than or equal to function which returns true if the first argument is greater than or equal to the second, it returns false otherwise.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"geq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("relation1","approx","This symbol is used to denote the approximate equality of its two arguments.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"approx\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMA> <OMS cd=\"nums1\" name=\"rational\"></OMS> <OMI> 355 </OMI> <OMI> 113 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("relation3",null,"This CD holds the basic equivalence relation notions.",new String[] {});
        register_omdef("relation3","is_relation","This symbol is a boolean function of two arguments, S and R. The first argument should be a set. When applied to S and R, the function returns true if and only if the second argument is a subset of the Cartesian product of S with itself.",new String[] {});
        register_omdef("relation3","equivalence_closure","This symbol represents a binary function whose first argument is a set S, whose second argument is a relation R on S. When applied to S and R, it represents the smallest equivalence relation (with respect to inclusion) on S containing R.",new String[] {});
        register_omdef("relation3","transitive_closure","This symbol represents a binary function whose first argument is a set S, whose second argument is a relation R on S. When applied to S and R, it represents the smallest transitive relation (with respect to inclusion) on S containing R.",new String[] {});
        register_omdef("relation3","reflexive_closure","This symbol represents a binary function whose first argument is a set S, whose second argument is a relation R on S. When applied to S and R, it represents the smallest reflexive relation (with respect to inclusion) on S containing R.",new String[] {});
        register_omdef("relation3","symmetric_closure","This symbol represents a binary function whose first argument is a set S, whose second argument is a relation R on S. When applied to S and R, it represents the smallest symmetric relation (with respect to inclusion) on S containing R.",new String[] {});
        register_omdef("relation3","is_transitive","This symbol represents the boolean binary function which returns true if and only if the second argument is a transitive relation on the first.",new String[] {});
        register_omdef("relation3","is_reflexive","This symbol represents the boolean binary function which returns true if and only if the second argument is a reflexive relation on the first.",new String[] {});
        register_omdef("relation3","is_symmetric","This symbol represents the boolean binary function which returns true if and only if the second argument is a symmetric relation on the first.",new String[] {});
        register_omdef("relation3","is_equivalence","This symbol represents the boolean binary function which returns true if and only if the second argument is a symmetric relation on the first.",new String[] {});
        register_omdef("relation3","class","This symbol represents a ternary function whose first argument is a set S, whose second argument is a relation R on S, and whose third argument is an element a of S. When applied to S, R, and a, it represents the set of all elements in S related to a by R, that is, the set {b in S | (a,b) in R}.",new String[] {});
        register_omdef("relation3","classes","This symbol represents a binary function whose first argument is a set S, whose second argument is a relation R on S. When applied to S and R, it represents the set of all elements in S of the form class(S,R,a) for a in S.",new String[] {});
        register_omdef("relation4",null,"This CD holds further definitions of symbols that represent relations in some way; at present this only includes a definition for n-ary equality.",new String[] {});
        register_omdef("relation4","eqs","This symbol is used to denote the n-ary version of equality. When applied to n arguments a1, ..., an, it represents the boolean expression that a1, a2, ,,, and an are equal.",new String[] {});
        register_omdef("ring1",null,"A CD of basic functions for ring theory",new String[] {});
        register_omdef("ring1","ring","This symbol is a constructor for rings. It takes six arguments R, a, o, i, m, e,: which are, respectively, a set R to specify the elements in the ring, a binary operation a on R, an element o of R, and a unary operation i on R such that [R,a,o,i] is a commutative group, a binary operation m on R and an element e of R such that [R,m,e] is a monoid.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMA><OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring1","carrier","This symbol represents a unary function, whose argument should be a ring S (for instance constructed by ring). When applied to S, its value should be the set of elements of S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"R\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","multiplication","This symbol represents a unary function, whose argument should be a ring S. It returns the multiplication map on S. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","negation","This symbol represents a unary function, whose argument should be a ring S. It returns the map sending an element of S to its additive inverse.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"negation\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"minus\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","identity","This symbols represents a unary function, whose argument should be a ring. It returns the identity element of the ring.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"identity\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"one\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","zero","This symbols represents a unary function, whose argument should be a ring. It returns the zero element of the ring.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"zero\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"zero\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","addition","This symbols represents a unary function, whose argument should be a ring. It returns the addition on the ring. We will allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"identity\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMV name=\"plus\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring1","subtraction","This symbols represents a unary function, whose argument should be a ring. It returns the binary operation of subtraction on the ring.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"subtraction\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV><OMV name=\"y\"></OMV> </OMBVAR> <OMA><OMV name=\"plus\"></OMV> <OMV name=\"x\"></OMV> <OMA><OMV name=\"minus\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("ring1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative ring.",new String[] {});
        register_omdef("ring1","is_subring","The binary boolean function whose value is true iff the second argument is a subring of the second.",new String[] {});
        register_omdef("ring1","additive_group","This symbol is a unary function, whose argument should be a ring S. When applied to S its value is the monoid underlying S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"additive_group\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"group1\" name=\"group\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring1","multiplicative_monoid","This symbol is a unary function, whose argument should be a ring S. When applied to S its value is the monoid underlying S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"multiplicative_monoid\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"plus\"></OMV> <OMV name=\"zero\"></OMV> <OMV name=\"minus\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"group1\" name=\"monoid\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"times\"></OMV> <OMV name=\"one\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring1","expression","This symbol is a function with two arguments. Its first argument should be a ring. The second should be an arithmetic expression A, whose operators are times, plus, minus, unary_minus, and power, and whose leaves are members of the carrier of G. (Here an integer m will be interpreted as a member of G by interpreting it as the sum of m copies of the identity element, the symbol alg1.one will be interpreted as the identity, and the symbol alg1.zero will be interpreted as the zero of G.) When applied to G and A, it denotes the element (of G) that is the element obtained from the leaves by applying the arithmetic operations of G instead of those from the CD arith1.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"expression\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>6</OMI><OMI>3</OMI> </OMA> </OMA> <OMI>18</OMI> </OMA> </OMOBJ>"});
        register_omdef("ring1","subring","This symbol is a constructor symbol with one or two arguments. The first argument is a list or set, D, of ring elements. The optional second argument is the ring G containing D. It denotes the subring of G generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring1\" name=\"subring\"></OMS> <OMV name=\"D\"></OMV> <OMV name=\"G\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring1\" name=\"subring\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> 1 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring1","power","This is a symbol with two or three arguments. Its first argument should be a an element g of a ring and the second argument should be an integer. The optional third argument is the ring G containing g. It denotes the element g^k in G.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring1\" name=\"power\"></OMS> <OMI>3</OMI> <OMI>2</OMI> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> </OMA> <OMI>6</OMI> </OMA> </OMOBJ>"});
        register_omdef("ring2",null,"Basic functions for homomorphisms in ring theory",new String[] {});
        register_omdef("ring2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are rings M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a ring homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are rings M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a ring isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a ring M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a ring endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring2","is_automorphism","This symbol is a boolean function with two arguments. The first is a ring M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a ring automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring2","left_multiplication","This symbol is a function with two arguments, which should be a ring M and an element x of M. When applied to M and x, it denotes left multiplication on M by x.",new String[] {});
        register_omdef("ring2","right_multiplication","This symbol is a function with two arguments, which should be a ring M and an element x of M. When applied to M and x, it denotes right multiplication on M by x.",new String[] {});
        register_omdef("ring2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are rings. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"group2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring3",null,"A CD of functions for basic constructions in ring theory. The quaternion definition is still very shaky.",new String[] {});
        register_omdef("ring3","is_ideal","The binary boolean function whose value is true if and only if the second argument is an ideal of the second.",new String[] {});
        register_omdef("ring3","ideal","This symbol represents a binary function. The first argument is a ring R and the second argument is a list or a set. When evaluated on R and such a second argument, the function represents the ideal in R generated by the entries of the list or set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"ideal\"></OMS> <OMA><OMS cd=\"ring3\" name=\"free_ring\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","kernel","This symbol represents a unary function. Its argument is a ring homomorphism f : R -> S. When evaluated on f, the function represents the kernel in R of f, that is, the subset {x in R | f(x) = 0}.",new String[] {});
        register_omdef("ring3","principal_ideal","This symbol represents a binary function. The first argument is a ring R and the second argument is an element of R. When evaluated on R and such a second argument, the function represents the ideal in R generated by the second argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"principal_ideal\"></OMS> <OMA><OMS cd=\"ring3\" name=\"free_ring\"></OMS> <OMS cd=\"fieldname1\" name=\"Q\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","free_ring","This symbol represents a binary function. The first argument should be a ring and the second a list or a set. When evaluated on such arguments R and L, the function represents the free ring over R generated by the elements (or entries) of L. This ring can also be viewed as the ring of non-commutative polynomials over R with variables the elements of L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"free_ring\"></OMS> <OMV name=\"R\"></OMV> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","poly_ring","This symbol represents a binary function. The first argument should be a ring and the second a variable. When evaluated on such arguments R and X, the function represents the free commutative ring over R generated by X. This ring can also be viewed as the ring of polynomials over R with indeterminate X.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMV name=\"R\"></OMV> <OMV name=\"X\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("ring3","m_poly_ring","This symbol represents a binary function. The first argument should be a ring and the second a list or a set. When evaluated on such arguments R and L, the function represents the free commutative ring over R generated by the elements (or entries) of L. This ring can also be viewed as the ring of polynomials over R with variables the elements of L.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"m_poly_ring\"></OMS> <OMV name=\"R\"></OMV> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","matrix_ring","This symbol represents a binary function. The first argument is a positive integer n, the second is a ring R. When evaluated on such argument n and R, the function represents the ring of n x n matrices over R.",new String[] {});
        register_omdef("ring3","direct_product","This is a symbol with two or more arguments, all of which are rings. It denotes the ring that is the direct product of its arguments.",new String[] {});
        register_omdef("ring3","direct_power","This is a symbol with two arguments. The first argument should be a ring S and the second argument a positive integer n. It denotes the direct product of n copies of S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"ring3\" name=\"direct_product\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMI>0</OMI> </OMA> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMI>0</OMI> </OMA> </OMA> <OMA><OMS cd=\"ring3\" name=\"direct_power\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMI>0</OMI> </OMA> <OMI>2</OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","quotient_ring","This is a binary function, whose first argument is a ring R and whose second argument is an ideal I of R. When applied to R and I, it denotes the quotient ring of R by I.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"quotient_ring\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"ring3\" name=\"ideal\"></OMS> <OMA><OMS cd=\"ring1\" name=\"ring\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMI>0</OMI> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>1</OMI> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMI>2</OMI> </OMA> </OMA> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"ring3\" name=\"quotient_ring\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMA><OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI>2</OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMA><OMS cd=\"ring3\" name=\"ideal\"></OMS> <OMA><OMS cd=\"ring3\" name=\"poly_ring\"></OMS> <OMA><OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI>2</OMI> </OMA> <OMV name=\"x\"></OMV> </OMA> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI>2</OMI> </OMA> <OMV name=\"x\"></OMV> <OMI>1</OMI> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("ring3","multiplicative_group","This is a unary function, whose argument is a ring R. When applied to R, it denotes the group of invertible elements of R with respect to the multiplication on R.",new String[] {});
        register_omdef("ring3","invertibles","This is a unary function, whose argument is a ring R. When applied to R, it denotes the set of invertible elements of R with respect to the multiplication on R.",new String[] {});
        register_omdef("ring3","integers","This is a symbol representing the ring of integers.",new String[] {});
        register_omdef("ring4",null,"A CD of functions for further basic properties of rings",new String[] {});
        register_omdef("ring4","is_maximal_ideal","The binary boolean function whose value is true iff the second argument is a maximal ideal of the first.",new String[] {});
        register_omdef("ring4","is_prime_ideal","The binary boolean function whose value is true iff the second argument is a prime ideal of the first.",new String[] {});
        register_omdef("ring4","is_domain","This symbol represents a boolean unary function. The argument is a ring R. When evaluated on R, the function returns true if R is a domain and false otherwise. A domain is a commutative ring without zero divisors.",new String[] {});
        register_omdef("ring4","is_field","This is unary boolean function whose argument should be a ring R. The value is true if and only if the ring is commutative and every nonzero element has a multiplicative inverse.",new String[] {});
        register_omdef("ring4","is_zero_divisor","This symbol represents a boolean binary function. The first argument is a ring R, the second is an element x of R. When evaluated on R and x, the function returns true if x a zero divisor and nonzero in R.",new String[] {});
        register_omdef("ring5",null,"A CD of functions for relating ring elements their images in quotient rings",new String[] {});
        register_omdef("ring5","quotient_map","This symbol is a binary function whose first argument is a ring R and whose second argument is an ideal I of R. When applied to R and I, its value is the natural quotient map from R to the quotient ring R/I.",new String[] {});
        register_omdef("ring5","quotient_by_poly_map","This symbol is a binary function whose first argument is a ring R, and whose second argument is a univariate polynomial f with coefficients from R. So, if the indeterminate is X, when applied to R and f, the function has value the natural quotient map from R[X] to the quotient ring R[X]/(f).",new String[] {});
        register_omdef("ring5","homomorphism_by_generators","This is a function with three arguments the first two of which must be monoids F and K. The third argument should be a set or a list L of ordered pairs (lists of length 2). Each pair [x,y] from L consists of an element x from F and an element y from K. when applied to F, K, and L, the symbol represents the monoid homomorphism from F to K that maps the first entry x of each pair [x,y] to the second entry y of the same pair.",new String[] {});
        register_omdef("ring5","automorphism_group","This is a function with a single argument which must be a ring. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("ringname1",null,"A CD of names of frequently used rings in ring theory.",new String[] {});
        register_omdef("ringname1","Z","This symbol represents the ring of integers.",new String[] {});
        register_omdef("ringname1","quaternions","This symbol represents a unary function. Its argument is a ring R. When evaluated on R, the function represents the ring of quaternions over R, that is, the ring with basis 1,i,j,k over R such that ij=-ji=k, i^2=j^2=k^2=-1.",new String[] {});
        register_omdef("ringname1","Zm","This symbol represents the ring of integers modulo m, where m is not necessarily a prime. It takes one argument, the integer m.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"ringname1\" name=\"Zm\"></OMS> <OMI> 12 </OMI> </OMA> </OMOBJ>"});
        register_omdef("rounding1",null,"A CD of basic rounding concepts",new String[] {});
        register_omdef("rounding1","ceiling","The round up (to +infinity) operation.",new String[] {});
        register_omdef("rounding1","floor","The round down (to -infinity) operation.",new String[] {});
        register_omdef("rounding1","trunc","The round to zero operation.",new String[] {});
        register_omdef("rounding1","round","The round to nearest operation.",new String[] {});
        register_omdef("s_data1",null,"This CD holds the definitions of the basic statistical functions used on sample data. It is intended to be `compatible\\\' with the MathML elements representing statistical functions, though it does not cover the concept of random variable which is mentioned in MathML.",new String[] {});
        register_omdef("s_data1","mean","This symbol represents an n-ary function denoting the mean of its arguments. That is, their sum divided by their number.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"s_data1\" name=\"mean\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>"});
        register_omdef("s_data1","sdev","This symbol represents a function requiring two or more arguments, denoting the sample standard deviation of its arguments. That is, the square root of (the sum of the squares of the deviations from the mean of the arguments, divided by the number of arguments). See CRC Standard Mathematical Tables and Formulae, editor: Dan Zwillinger, CRC Press Inc., 1996, (7.7.11) section 7.7.1.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"s_data1\" name=\"sdev\"></OMS> <OMF dec=\"3.1\"></OMF> <OMF dec=\"2.2\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"1.1\"></OMF> <OMF dec=\"3.3\"></OMF> <OMF dec=\"2.4\"></OMF> <OMF dec=\"5.5\"></OMF> <OMF dec=\"2.3\"></OMF> <OMF dec=\"1.7\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"3.4\"></OMF> <OMF dec=\"4.0\"></OMF> <OMF dec=\"3.3\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("s_data1","variance","This symbol represents a function requiring two or more arguments, denoting the variance of its arguments. That is, the square of the standard deviation.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"s_data1\" name=\"variance\"></OMS> <OMF dec=\"3.1\"></OMF> <OMF dec=\"2.2\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"1.1\"></OMF> <OMF dec=\"3.3\"></OMF> <OMF dec=\"2.4\"></OMF> <OMF dec=\"5.5\"></OMF> <OMF dec=\"2.3\"></OMF> <OMF dec=\"1.7\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"3.4\"></OMF> <OMF dec=\"4.0\"></OMF> <OMF dec=\"3.3\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("s_data1","mode","This symbol represents an n-ary function denoting the mode of its arguments. That is the value which occurs with the greatest frequency.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"s_data1\" name=\"mode\"></OMS> <OMI> 1 </OMI> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMI> 1 </OMI> </OMA> </OMOBJ>"});
        register_omdef("s_data1","median","This symbol represents an n-ary function denoting the median of its arguments. That is, if the data were placed in ascending order then it denotes the middle one (in the case of an odd amount of data) or the average of the middle two (in the case of an even amount of data).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"s_data1\" name=\"median\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMI> 2 </OMI> </OMA> </OMOBJ>"});
        register_omdef("s_data1","moment","This symbol is used to denote the i\\\'th moment of a set of data. The first argument should be the degree of the moment (that is, for the i\\\'th moment the first argument should be i), the second argument should be the point about which the moment is being taken and the rest of the arguments are treated as the data. For n data values x_1, x_2, ..., x_n the i\\\'th moment about c is (1/n) ((x_1-c)^i + (x_2-c)^i + ... + (x_n-c)^i). See CRC Standard Mathematical Tables and Formulae, editor: Dan Zwillinger, CRC Press Inc., 1996, section 7.7.1.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"s_data1\" name=\"moment\"></OMS> <OMI> 2 </OMI> <OMS cd=\"alg1\" name=\"zero\"></OMS> <OMF dec=\"3.1\"></OMF> <OMF dec=\"2.2\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"1.1\"></OMF> <OMF dec=\"3.3\"></OMF> <OMF dec=\"2.4\"></OMF> <OMF dec=\"5.5\"></OMF> <OMF dec=\"2.3\"></OMF> <OMF dec=\"1.7\"></OMF> <OMF dec=\"1.8\"></OMF> <OMF dec=\"3.4\"></OMF> <OMF dec=\"4.0\"></OMF> <OMF dec=\"3.3\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("s_dist1",null,"This CD holds the definitions of the basic statistical functions used on random variables. It is intended to be `compatible\\\' with the MathML elements representing statistical functions.",new String[] {});
        register_omdef("s_dist1","mean","This symbol represents a unary function denoting the mean of a distribution. The argument is a univariate function to describe the distribution. That is, if f is the function describing the distribution. The mean is the expression integrate(x*f(x)) w.r.t. x over the range (-infinity,infinity).",new String[] {});
        register_omdef("s_dist1","sdev","This symbol represents a unary function denoting the standard deviation of a distribution. The argument is a univariate function to describe the distribution. The standard deviation of a distribution is the arithmetical mean of the squares of the deviation of the distribution from the mean.",new String[] {});
        register_omdef("s_dist1","variance","This symbol represents a unary function denoting the variance of a distribution. The argument is a function to describe the distribution. That is if f is the function which describes the distribution. The variance of a distribution is the square of the standard deviation of the distribution.",new String[] {});
        register_omdef("s_dist1","moment","This symbol represents a ternary function to denote the i\\\'th moment of a distribution. The first argument should be the degree of the moment (that is, for the i\\\'th moment the first argument should be i), the second argument is the value about which the moment is to be taken and the third argument is a univariate function to describe the distribution. That is, if f is the function which describe the distribution. The i\\\'th moment of f about a is the integral of (x-a)^i*f(x) with respect to x, over the interval (-infinity,infinity).",new String[] {});
        register_omdef("scscp1",null,"This CD defines symbols for the description of the management of mathematical queries. In particular, it is used by the SCIEnce project [SCIEnce website] in the communication between a web service (i.e. computer algebra system, proof checker, etc) and a client. SCSCP is an abbreviation for \\\"Symbolic Computation Software Composability Protocol\\\" [SCSCP specification]. This version of the Content Dictionary agrees with version 1.3 of the SCSCP protocol.",new String[] {});
        register_omdef("scscp1","procedure_call","The actual procedure call. It is an OpenMath Application, whose first argument is the symbol of the procedure, and the other arguments are the arguments to the procedure.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_runtime\"></OMS> <OMI>300000</OMI> <OMS cd=\"scscp1\" name=\"option_min_memory\"></OMS> <OMI>40964</OMI> <OMS cd=\"scscp1\" name=\"option_max_memory\"></OMS> <OMI>134217728</OMI> <OMS cd=\"scscp1\" name=\"option_debuglevel\"></OMS> <OMI>2</OMI> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp_transient_1\" name=\"GroupIdentificationService\"></OMS> <OMA> <OMS cd=\"group1\" name=\"group\"></OMS> <OMA> <OMS cd=\"permut1\" name=\"permutation\"></OMS> <OMI> 2</OMI> <OMI> 3</OMI> <OMI> 1</OMI> </OMA> <OMA> <OMS cd=\"permut1\" name=\"permutation\"></OMS> <OMI> 1</OMI> <OMI> 2</OMI> <OMI> 4</OMI> <OMI> 3</OMI> </OMA> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","procedure_completed","The result of a successful computation. Should come along with a call_id and, possibly, some extra information.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>a1d0c6e83f027327d8461063f4ac58a6</OMSTR> <OMS cd=\"scscp1\" name=\"info_runtime\"></OMS> <OMI>72643</OMI> <OMS cd=\"scscp1\" name=\"info_memory\"></OMS> <OMI>52876</OMI> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMI>26925748508234281076009</OMI> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>a1d0c6e83f027327d8461063f4ac58a6</OMSTR> <OMS cd=\"scscp1\" name=\"info_runtime\"></OMS> <OMI>72643</OMI> <OMS cd=\"scscp1\" name=\"info_memory\"></OMS> <OMI>52876</OMI> </OMATP> <OMR href=\"scscp://somehost:26133/92cfceb39d57d914ed8b14d0e37643de0797ae56\"></OMR> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","procedure_terminated","The result of a failed computation. Should come along with a call_id, an error description, and possibly some extra information.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>a24904e5d3ed28eae9225fd787f64a71</OMSTR> <OMS cd=\"scscp1\" name=\"info_runtime\"></OMS> <OMSTR>21897</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_terminated\"></OMS> <OME> <OMS cd=\"scscp1\" name=\"error_system_specific\"></OMS> <OMSTR>Segmentation fault</OMSTR> </OME> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","call_id","Uniquely identifies a procedure call. Used in subsequent communication, so the parties know which call they are talking about.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>a1d0c6e83f027327d8461063f4ac58a6</OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_max_memory","An option, to be given along with a procedure call, describing the maximum amount of memory (in bytes) the system should spend on this call.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_max_memory\"></OMS> <OMI>20971520</OMI> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_min_memory","An option, to be given along with a procedure call, describing the minimum amount of memory (in bytes) the system should be able to spend on this call. The idea is that in certain cases we know in advance that we will need a large amount of memory. If the system will never be able to provide that, it would be a waste of time and resources to even start the computation.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_min_memory\"></OMS> <OMI>250971520</OMI> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_runtime","An option, to be given along with a procedure call, describing the maximum amount of time (in milliseconds) the system should spend on this call.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_runtime\"></OMS> <OMI>600000</OMI> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_debuglevel","An option, to be given along with a procedure call, describing the amount of debug information the client is interested in. Should be an integer.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_debuglevel\"></OMS> <OMI>2</OMI> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_return_cookie","An option, to be given along with a procedure call, indicating that the client would like to have a cookie (i.e. a reference to an OpenMath object residing somewhere) as return value.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_cookie\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMR href=\"scscp://somehost.somedomain:26133/q9t4eX\"></OMR> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_return_object","An option, to be given along with a procedure call, indicating that the client would like to have the actual OpenMath object as return value.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMI>42</OMI> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","option_return_nothing","An option, to be given along with a procedure call, indicating that the client expects no return value.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_nothing\"></OMS> <OMSTR></OMSTR> </OMATP> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","info_memory","A piece of information from the system, to be used along with a procedure_completed or procedure_terminated message, describing how much memory was spent on the calculation. It should be in bytes, denoted using an OMI.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"info_memory\"></OMS> <OMI>134218000</OMI> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","info_runtime","A piece of information from the system, to be used along with a procedure_completed or procedure_terminated message, describing how much cputime was spent on the calculation. It should be in milliseconds, denoted using an OMI.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"info_runtime\"></OMS> <OMI>76543</OMI> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","info_message","A piece of information from the server, to be used along with a procedure_completed or procedure_terminated message, giving some additional information. The client may choose to present this information to its user. The argument is an OMSTR.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>localhost:26137:18668:s2sYf1pg</OMSTR> <OMS cd=\"scscp1\" name=\"info_message\"></OMS> <OMSTR>The weather in St. Andrews is beautiful this time of year</OMSTR> </OMATP> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","error_memory","A description of the error that caused a procedure call to be terminated. This symbol is used with a procedure_terminated, when the system exceeded the amount of memory specified in the option_max_memory option given in the corresponding procedure call. It carries one argument: An OMSTR, which may be empty.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_terminated\"></OMS> <OME> <OMS cd=\"scscp1\" name=\"error_memory\"></OMS> <OMSTR></OMSTR> </OME> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","error_runtime","A description of the error that caused a procedure call to be terminated. This symbol is used with a procedure_terminated, when the system exceeded the runtime specified in the option_runtime option given in the corresponding procedure call. It carries one argument: An OMSTR, which may be empty. Note that this symbol is not intended to be used when a different runtime error occurred. In those cases, one should use error_system_specific.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_terminated\"></OMS> <OME> <OMS cd=\"scscp1\" name=\"error_runtime\"></OMS> <OMSTR></OMSTR> </OME> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp1","error_system_specific","A description of the error that caused a procedure call to be terminated. This symbol is used with a procedure_terminated, when the error is specific to the system that carried out the calculation.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\"> <OMATTR> <OMATP> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_terminated\"></OMS> <OME> <OMS cd=\"scscp1\" name=\"error_system_specific\"></OMS> <OMSTR>Error, the group identification for groups of size\\n 3628800 is not available called from\\n &lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop\\n Entering break read-eval-print loop ...\\n you can \'quit;\' to quit to outer loop, or\\n you can \'return;\' to continue\\n brk&gt;\\n </OMSTR> </OME> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2",null,"This CD defines symbols for the description of the management of mathematical queries. In particular, it is used by the SCIEnce project [SCIEnce website] in the communication between a web service (i.e. computer algebra system, proof checker, etc) and a client. SCSCP is an abbreviation for \\\"Symbolic Computation Software Composability Protocol\\\" [SCSCP specification]. The objects in this CD are somewhat more sophisticated than those in scscp1, and some SCSCP compliant applications may not support these. The symbols in this CD mainly serve two purposes: working with remote objects ( , , , ) and determining the procedures a system supports ( , , , , , , ). There are also some special symbols ( , , ) This version of the Content Dictionary agrees with version 1.3 of the SCSCP protocol.",new String[] {});
        register_omdef("scscp2","store_session","This indicates the request to store an object on the server side (possibly after computing or simplifying it), returning only a cookie (actually, OM reference) pointing to that object that is usable in the remainder of the current SCSCP session to get access to the actual object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882860</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"store_session\"></OMS> <OMI>6177887</OMI> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882860</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMR href=\"scscp://somewhere:26133/qjhtkoeurthoedu\"></OMR> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","store_persistent","This indicates the request to store an object on the server side (possibly after computing or simplifying it), returning only a cookie (actually, OM reference) pointing to that object that is usable in the foreseeable future, possibly from different sessions, to get access to the actual object. The server is encouraged to describe the expected lifetime of this object and whether references to this object from different SCSCP sessions are allowed in the response to a request on this symbol. However, at this time we provide no automated or machine-readable mechanism for handling these lifetimes.",new String[] {});
        register_omdef("scscp2","retrieve","Using the cookie that was obtained earlier by calling the or procedure or another procedure call, return to the client an OM object representing the object, referred by the cookie.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882861</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"retrieve\"></OMS> <OMR href=\"scscp://somewhere:26133/qjhtkoeurthoedu\"></OMR> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882861</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMI>6177887</OMI> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","unbind","This indicates the request to remove the object, referred by the cookie, from the server.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882862</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"unbind\"></OMS> <OMR href=\"scscp://somewhere:26133/qjhtkoeurthoedu\"></OMR> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>9882862</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","get_allowed_heads","This symbol is used to find the list of procedures supported by an SCSCP server.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324765</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"get_allowed_heads\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324765</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"symbol_set\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"GroupIdentificationService\"></OMS> <OMS cd=\"group1\" name=\"group\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>permut1</OMSTR> </OMA> <OMA> <OMS cd=\"metagrp\" name=\"CDGroupName\"></OMS> <OMSTR>scscp</OMSTR> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","is_allowed_head","This symbol is used to find whether a particular procedure is supported by an SCSCP server. The reply must be either true or false, described in one of the appropriate symbols from the logic1 content dictionary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>xy87263</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"is_allowed_head\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>xy87263</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMS cd=\"logic1\" name=\"false\"></OMS> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>xy87263</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"is_allowed_head\"></OMS> <OMS cd=\"scscp2\" name=\"is_allowed_head\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>xy87263</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMS cd=\"logic1\" name=\"true\"></OMS> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","get_transient_cd","This symbol is used to get the contents of a transient CD created by a server.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324766</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"get_transient_cd\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>scscp_transient_1</OMSTR> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324766</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CD\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>scscp_transient_1</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDDate\"></OMS> <OMSTR>2007-08-24</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"Description\"></OMS> <OMSTR>CD created by the service provider</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDDefinition\"></OMS> <OMA> <OMS cd=\"meta\" name=\"Name\"></OMS> <OMSTR>GroupIdentificationService</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"Description\"></OMS> <OMSTR>IdGroup(permgroup by gens)</OMSTR> </OMA> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","get_signature","A symbol for the client to inquire about the signature of a particular function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324767</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"get_signature\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"GroupIdentificationService\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","get_service_description","A symbol for the client to ask for some description of a service.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324769</OMSTR> <OMS cd=\"scscp1\" name=\"option_return_object\"></OMS> <OMSTR></OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_call\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"get_service_description\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"GroupIdentificationService\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","signature","The symbol to use for describing the types of arguments of a particular function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324767</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"signature\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"GroupIdentificationService\"></OMS> <OMI>1</OMI> <OMI>1</OMI> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"symbol_set\"></OMS> <OMS cd=\"group1\" name=\"group\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>permut1</OMSTR> </OMA> </OMA> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324767</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"signature\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"CAS_Service\"></OMS> <OMI>0</OMI> <OMS cd=\"nums1\" name=\"infinity\"></OMS> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMA> <OMS cd=\"meta\" name=\"CDGroupName\"></OMS> <OMSTR>scscp</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>scscp_transient_0</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>scscp_transient_1</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>arith1</OMSTR> </OMA> <OMA> <OMS cd=\"meta\" name=\"CDName\"></OMS> <OMSTR>transc1</OMSTR> </OMA> </OMA> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","service_description","The symbol for the server to use when describing one of his services.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324769</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"service_description\"></OMS> <OMSTR>This service enables you to lookup a particular group in the GAP Small Groups Library</OMSTR> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","symbol_set","This symbol is used in the reply to a call. It should be the head of an OM Application, the contents of the OMA being arbitrarily many OM Symbols (meaning that a particular symbol is supported), OMA\\\'s with head (meaning that all symbols of a particular CD are supported) or OMA\\\'s with head (meaning that all symbols of all CDs of a particular CD group are supported). See the example at .",new String[] {});
        register_omdef("scscp2","symbol_set_all","This symbol is used in the reply to a message. It means that this particular service takes any OpenMath object as argument.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OMATTR> <OMATP> <OMS cd=\"scscp1\" name=\"call_id\"></OMS> <OMSTR>1324767</OMSTR> </OMATP> <OMA> <OMS cd=\"scscp1\" name=\"procedure_completed\"></OMS> <OMA> <OMS cd=\"scscp2\" name=\"signature\"></OMS> <OMS cd=\"scscp_transient_1\" name=\"Something\"></OMS> <OMI>0</OMI> <OMS cd=\"nums1\" name=\"infinity\"></OMS> <OMS cd=\"scscp2\" name=\"symbol_set_all\"></OMS> </OMA> </OMA> </OMATTR> </OMOBJ>"});
        register_omdef("scscp2","no_such_transient_cd","Used for errors that arise when the client asks for a transient cd that the server cannot handle.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" xmlns:html=\"http://www.w3.org/1999/XHTML\" xmlns:om=\"http://www.openmath.org/OpenMath\"> <OME> <OMS cd=\"scscp2\" name=\"no_such_transient_cd\"></OMS> <OMSTR>scscp_transient_7</OMSTR> </OME> </OMOBJ>"});
        register_omdef("semigroup",null,"The definition of a semigroup as setoid with a binary operation. Initial version: O. Caprotti",new String[] {});
        register_omdef("semigroup","associative","The type of associative binary operation.",new String[] {});
        register_omdef("semigroup","Semigroup","The contructor for the type of semigroups as a Setoid with a binary operation.",new String[] {});
        register_omdef("semigroup","make_Semigroup","The contructor for the tuples consisting of a setoid, and an associative binary operation.",new String[] {});
        register_omdef("semigroup1",null,"Basic functions for semigroup theory",new String[] {});
        register_omdef("semigroup1","semigroup","This symbol is a constructor for semigroups. It takes two arguments in the following order: a set to specify the elements in the semigroup, and a binary operation to specify the semigroup operation. The binary operation should act on elements of the set and return an element of the set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> </OMA> <OMS cd=\"fns1\" name=\"left_compose\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","carrier","This symbol represents a unary function, whose argument should be a semigroup S (for instance constructed by semigroup). When applied to S, its value should be the set of elements of S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMV name=\"S\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> <OMV name=\"S\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","multiplication","This symbol represents a unary function, whose argument should be a semigroup S. It returns the multiplication map on S. We allow for the map to be n-ary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"multiplication\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMV name=\"S\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> <OMV name=\"times\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","is_commutative","The unary boolean function whose value is true iff the argument is a commutative semigroup.",new String[] {});
        register_omdef("semigroup1","is_subsemigroup","The binary boolean function whose value is true iff the second argument is a subsemigroup of the second.",new String[] {});
        register_omdef("semigroup1","magma","This symbol is a unary function. Its argument should be a semigroup S. When applied to S, it denotes the magma with the same element set and binary operation as S.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"magma\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> <OMA><OMS cd=\"magma1\" name=\"magma\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"times\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","subsemigroup","This symbol is a constructor symbol with two arguments. The first argument is a semigroup S, the second a list or set, D, of elements of S. When applied to S and D, it denotes the subsemigroup of S generated by D.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup1\" name=\"subsemigroup\"></OMS> <OMV name=\"S\"></OMV> <OMV name=\"D\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMA><OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA><OMS cd=\"relation1\" name=\"neq\"></OMS> <OMV name=\"x\"></OMV> <OMS cd=\"alg1\" name=\"zero\"></OMS> </OMA> </OMBIND> </OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> </OMA> <OMA> <OMS cd=\"list1\" name=\"list\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMS cd=\"nums1\" name=\"e\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","factor_of","This symbol is a ternary function. Its first argument should be a semigroup S and the second and third arguments should be elements of S. When applied to S, a, and b, it denotes the fact that a is a divisor of b in S. This means that there are u,v in carrier(S) such that uav=b.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup1\" name=\"factor_of\"></OMS> <OMV name=\"S\"></OMV> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup1","expression","This symbol is a function with two arguments. Its first argument should be a semigroup G. The second should be an arithmetic expression A, whose operators are times and power, and whose leaves are members of the carrier of G. The second argument of power should be positive. When applied to G and A, it denotes the element (of G) that is obtained from the leaves of A by applying the multiplication and the power map of G instead of the times and power of the CD arith1 appearing in A.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"group1\" name=\"expression\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"semigroup\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> </OMA> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMI>2</OMI><OMI>3</OMI> </OMA> </OMA> <OMI>5</OMI> </OMA> </OMOBJ>"});
        register_omdef("semigroup2",null,"Basic functions for semigroup theory",new String[] {});
        register_omdef("semigroup2","is_homomorphism","This symbol is a boolean function with three arguments. The first and arguments are semigroups M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a semigroup homomorphism from M to N.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup2\" name=\"is_homomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup2","is_isomorphism","This symbol is a boolean function with three arguments. The first and arguments are semigroups M, N, the third is a map f from the element set of M to the element set of N. When applied to M, N, and f, it denotes that f is a semigroup isomorphism from M to N. This means that f is a homomorphism from M to N, that f is bijective, and that its inverse is a homomorphism from N to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup2\" name=\"is_isomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup2","is_endomorphism","This symbol is a boolean function with two arguments. The first argument is a semigroup M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes that f is a semigroup endomorphism from M to M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup2\" name=\"is_endomorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup2","is_automorphism","This symbol is a boolean function with two arguments. The first is a semigroup M, the second is a map f from the element set of M to the element set of M. When applied to M and f, it denotes a semigroup automorphism f of M.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup2\" name=\"is_automorphism\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"f\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup2","left_multiplication","This symbol is a function with two arguments, which should be a semigroup M and an element x of M. When applied to M and x, it denotes left multiplication on M by x.",new String[] {});
        register_omdef("semigroup2","right_multiplication","This symbol is a function with two arguments, which should be a semigroup M and an element x of M. When applied to M and x, it denotes right multiplication on M by x.",new String[] {});
        register_omdef("semigroup2","isomorphic","This symbol is a Boolean function with n arguments, n at least 2, which are semigroups. When applied to M_1, ..., M_n, it denotes the fact that there is an isomorphism from each M_i to each M_j.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup2\" name=\"isomorphic\"></OMS> <OMV name=\"M\"></OMV> <OMV name=\"N\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("semigroup3",null,"Semigroup constructions",new String[] {});
        register_omdef("semigroup3","cyclic_semigroup","This symbol denotes the cyclic semigroup with a cycle of length l and a tail of length k.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"set1\" name=\"size\"></OMS> <OMA><OMS cd=\"semigroup1\" name=\"carrier\"></OMS> <OMA><OMS cd=\"semigroup3\" name=\"cyclic_semigroup\"></OMS> <OMV name=\"k\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMA> <OMA><OMS cd=\"arith1\" name=\"plus\"></OMS> <OMV name=\"k\"></OMV> <OMV name=\"l\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("semigroup3","maps_semigroup","This is a unary function whose argument must be a set X or a positive integer. When applied to X, it refers to the semigroup of all functions from X to X if X is a set and to {1,...,X} if X is an integer, whose binary operation is composition of maps and whose identity element is the identity map on the set X, respectively {1,...,X}.",new String[] {});
        register_omdef("semigroup3","left_regular_representation","This is a unary function whose argument must be a semigroup M. When applied to M, it represents the map from M to the maps semigroup on M that assigns to m left multiplication by m on M.",new String[] {});
        register_omdef("semigroup3","automorphism_group","This is a function with a single argument which must be a semigroup. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("semigroup3","direct_product","This is an n-ary function whose arguments must be semigroups. It refers to the direct product of its arguments.",new String[] {});
        register_omdef("semigroup3","direct_power","This is a binary function whose first argument should be a semigroup M and whose second argument should be a natural number n. It refers to the direct product of n copies of M.",new String[] {});
        register_omdef("semigroup3","free_semigroup","This symbol represents a binary function. The argument is a list or a set. When evaluated on such an argument, the function represents the free semigroup generated by the entries of the list or set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"semigroup3\" name=\"free_semigroup\"></OMS> <OMA><OMS cd=\"list1\" name=\"list\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("semigroup4",null,"A CD of functions for morphisms of semigroups.",new String[] {});
        register_omdef("semigroup4","automorphism_group","This is a function with a single argument which must be a semigroup. It refers to the automorphism group of its argument.",new String[] {});
        register_omdef("semigroup4","homomorphism_by_generators","This is a function with three arguments the first two of which must be semigroups F and K. The third argument should be a set or a list L of ordered pairs (lists of length 2). Each pair [x,y] from L consists of an element x from F and an element y from K. when applied to F, K, and L, the symbol represents the homomorphism from F to K that maps the first entry x of each pair [x,y] to the second entry y of the same pair.",new String[] {});
        register_omdef("set1",null,"This CD defines the set functions and constructors for basic set theory. It is intended to be `compatible\\\' with the corresponding elements in MathML.",new String[] {});
        register_omdef("set1","cartesian_product","This symbol represents an n-ary construction function for constructing the Cartesian product of sets. It takes n set arguments in order to construct their Cartesian product.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"cartesian_product\"></OMS> <OMV name=\"A\"></OMV> <OMV name=\"B\"></OMV> <OMV name=\"C\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("set1","emptyset","This symbol is used to represent the empty set, that is the set which contains no members. It takes no parameters.",new String[] {});
        register_omdef("set1","map","This symbol represents a mapping function which may be used to construct sets, it takes as arguments a function from X to Y and a set over X in that order. The value that is returned is a set of values in Y. The argument list may be a set or an integer_interval.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"map\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMI> 2 </OMI> <OMV name=\"x\"></OMV> </OMA> </OMBIND> <OMA> <OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 0 </OMI> <OMI> 10 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set1","size","This symbol is used to denote the number of elements in a set. It is either a non-negative integer, or an infinite cardinal number. The symbol infinity may be used for an unspecified infinite cardinal.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"set1\" name=\"size\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMA> <OMI> 3 </OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"set1\" name=\"size\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> <OMS cd=\"nums1\" name=\"infinity\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("set1","suchthat","This symbol represents the suchthat function which may be used to construct sets, it takes two arguments. The first argument should be the set which contains the elements of the set we wish to represent, the second argument should be a predicate, that is a function from the set to the booleans which describes if an element is to be in the set returned.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"suchthat\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND> <OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> </OMBVAR> <OMA> <OMS cd=\"set1\" name=\"in\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("set1","set","This symbol represents the set construct. It is an n-ary function. The set entries are given explicitly. There is no implied ordering to the elements of a set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 3 </OMI> <OMI> 6 </OMI> <OMI> 9 </OMI> </OMA> </OMOBJ>"});
        register_omdef("set1","intersect","This symbol is used to denote the n-ary intersection of sets. It takes sets as arguments, and denotes the set that contains all the elements that occur in all of them.",new String[] {});
        register_omdef("set1","union","This symbol is used to denote the n-ary union of sets. It takes sets as arguments, and denotes the set that contains all the elements that occur in any of them.",new String[] {});
        register_omdef("set1","setdiff","This symbol is used to denote the set difference of two sets. It takes two sets as arguments, and denotes the set that contains all the elements that occur in the first set, but not in the second.",new String[] {});
        register_omdef("set1","subset","This symbol has two (set) arguments. It is used to denote that the first set is a subset of the second.",new String[] {});
        register_omdef("set1","in","This symbol has two arguments, an element and a set. It is used to denote that the element is in the given set.",new String[] {});
        register_omdef("set1","notin","This symbol has two arguments, an element and a set. It is used to denote that the element is not in the given set.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"notin\"></OMS> <OMI> 4 </OMI> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set1","prsubset","This symbol has two (set) arguments. It is used to denote that the first set is a proper subset of the second, that is a subset of the second set but not actually equal to it.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"prsubset\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set1","notsubset","This symbol has two (set) arguments. It is used to denote that the first set is not a subset of the second.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"notsubset\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> <OMI> 4 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set1","notprsubset","This symbol has two (set) arguments. It is used to denote that the first set is not a proper subset of the second. A proper subset of a set is a subset of the set but not actually equal to it.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"set1\" name=\"notprsubset\"></OMS> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set2",null,"This CD defines more set functions;",new String[] {});
        register_omdef("set2","lift_binary","This symbol denotes the lift of a binary operator on elements of X to a component-wise operators on subsets of X.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMA> <OMS cd=\"set2\" name=\"lift_binary\"></OMS> <OMS cd=\"arith1\" name=\"plus\"></OMS> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 1 </OMI> <OMI> 2 </OMI> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 2 </OMI> <OMI> 3 </OMI> </OMA> </OMA> <OMA> <OMS cd=\"set1\" name=\"set\"></OMS> <OMI> 3 </OMI> <OMI> 4 </OMI> <OMI> 5 </OMI> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set3",null,"This CD defines more set functions.",new String[] {});
        register_omdef("set3","big_intersect","This symbol is a unary function whose argument should be a collection C of subsets of a given set. When applied to C, it represents the intersection over all members of C.",new String[] {});
        register_omdef("set3","big_union","This symbol is a unary function whose argument should be a collection C of subsets of a given set. When applied to C, it represents the union over all members of C.",new String[] {});
        register_omdef("set3","cartesian_power","This symbol is a binary function whose first argument should be a set A and whose second argument should be a natural number k. When applied to A and k, it represents the Cartesian product of k copies of A.",new String[] {});
        register_omdef("set3","powerset","This symbol represents unary function whose argument should be a set. When applied to a set X, it represents the collection of all subsets of X.",new String[] {});
        register_omdef("set3","k_subsets","This symbol represents a binary function whose first argument should be a set and whose second argument should be a natural number. When applied to a set X and a number k, it represents the collection of all subsets of X of size k.",new String[] {});
        register_omdef("set3","map_with_target","This symbol represents a function with three arguments. The first argument is a function assignment f (in the form of a lambda binding), the second argument is a set X on which the first argument f is defined. The third argument specifies the range Y of the function. The symbol is used to denote the image {f(x) in Y | x in X} of application of the function f on the elements of X (so as to form a subset of Y).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"set3\" name=\"map_with_target\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMBIND> <OMA><OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"Y\"></OMV> </OMA> <OMA><OMS cd=\"set3\" name=\"map_with_target\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMBVAR> <OMA><OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"x\"></OMV> <OMV name=\"y\"></OMV> </OMA> </OMBIND> <OMA><OMS cd=\"set1\" name=\"cartesian_product\"></OMS> <OMV name=\"X\"></OMV> <OMV name=\"Y\"></OMV> </OMA> <OMV name=\"G\"></OMV> </OMA> </OMA> </OMOBJ>"});
        register_omdef("set3","map_with_condition","This symbol represents a function with three arguments. The first argument is a function assignment f (in the form of a lambda binding), the second argument is a set X. The third argument specifies a Boolean function P on X defining the subset Z of X (so Z = {x in X| P(x)}) on which the first argument f is defined, The symbol is used to denote the image {f(x) | x in X and P(x)} of application of the function f on the elements of Z.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"set3\" name=\"map_with_condition\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMBIND> <OMA><OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"integer2\" name=\"divides\"></OMS> <OMI> 2 </OMI><OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("set3","map_with_target_and_condition","This symbol represents a function with four arguments. The first argument is a function assignment f (in the form of a lambda binding), the second argument is a set X on which the first argument f is defined. The third argument specifies the range Y of the function. The fourth argument specifies a Boolean function P on X defining the subset Z of X (so Z = {x in X| P(x)}) on which the first argument f is defined, The symbol is used to denote the image {f(x) in Y | x in X and P(x)} of application of the function f on the elements of Z.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" version=\"2.0\"> <OMA><OMS cd=\"set3\" name=\"map_with_target_and_condition\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"x\"></OMV> <OMI> 2 </OMI> </OMA> </OMBIND> <OMA><OMS cd=\"interval1\" name=\"integer_interval\"></OMS> <OMI> 1 </OMI> <OMI> 10 </OMI> </OMA> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMBIND><OMS cd=\"fns1\" name=\"lambda\"></OMS> <OMBVAR><OMV name=\"x\"></OMV></OMBVAR> <OMA><OMS cd=\"integer2\" name=\"divides\"></OMS> <OMI> 2 </OMI><OMV name=\"x\"></OMV> </OMA> </OMBIND> </OMA> </OMOBJ>"});
        register_omdef("setname1",null,"This CD defines common sets of mathematics",new String[] {});
        register_omdef("setname1","P","This symbol represents the set of positive prime numbers.",new String[] {});
        register_omdef("setname1","N","This symbol represents the set of natural numbers (including zero).",new String[] {});
        register_omdef("setname1","Z","This symbol represents the set of integers, positive, negative and zero.",new String[] {});
        register_omdef("setname1","Q","This symbol represents the set of rational numbers.",new String[] {});
        register_omdef("setname1","R","This symbol represents the set of real numbers.",new String[] {});
        register_omdef("setname1","C","This symbol represents the set of complex numbers.",new String[] {});
        register_omdef("setname2",null,"This CD defines some common sets of mathematics.",new String[] {});
        register_omdef("setname2","Boolean","This symbol represents the set of Booleans. That is the truth values, true and false.",new String[] {});
        register_omdef("setname2","A","This symbol represents the set of algebraic numbers.",new String[] {});
        register_omdef("setname2","Zm","This symbol represents the set of integers modulo m, where m is not necessarily a prime. It takes one argument, the integer m.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI> 12 </OMI> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMV name=\"m\"></OMV> </OMA> </OMOBJ>", "<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMATTR> <OMATP> <OMS cd=\"sts\" name=\"type\"></OMS> <OMA> <OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI> 12 </OMI> </OMA> </OMATP> <OMI> 4 </OMI> </OMATTR> <OMATTR> <OMATP> <OMS cd=\"sts\" name=\"type\"></OMS> <OMA> <OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI> 12 </OMI> </OMA> </OMATP> <OMI> 5 </OMI> </OMATTR> </OMA> <OMATTR> <OMATP> <OMS cd=\"sts\" name=\"type\"></OMS> <OMA> <OMS cd=\"setname2\" name=\"Zm\"></OMS> <OMI> 12 </OMI> </OMA> </OMATP> <OMI> 8 </OMI> </OMATTR> </OMA> </OMOBJ>"});
        register_omdef("setname2","GFp","This symbol represents the finite field of integers modulo p, where p is a prime.",new String[] {});
        register_omdef("setname2","GFpn","This symbol represents the finite field with p^n elements, where p is a prime.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"setname2\" name=\"GFp\"></OMS> <OMV name=\"p\"></OMV> </OMA> <OMA> <OMS cd=\"setname2\" name=\"GFpn\"></OMS> <OMV name=\"p\"></OMV> <OMS cd=\"alg1\" name=\"one\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("setname2","QuotientField","This symbol represents the quotient field of any integral domain.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMS cd=\"setname1\" name=\"Q\"></OMS> <OMA> <OMS cd=\"setname2\" name=\"QuotientField\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> </OMA> </OMA> </OMOBJ>"});
        register_omdef("setname2","H","This symbol represents the set of quaternions.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMBIND> <OMS cd=\"quant1\" name=\"exists\"></OMS> <OMBVAR> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMBVAR> <OMA> <OMS cd=\"relation1\" name=\"neq\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"a\"></OMV> <OMV name=\"b\"></OMV> </OMA> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMV name=\"b\"></OMV> <OMV name=\"a\"></OMV> </OMA> </OMA> </OMBIND> </OMOBJ>"});
        register_omdef("setoid",null,"The definition of a setoid as a set with an equivalence relations defined on its elements. Initial version: O. Caprotti",new String[] {});
        register_omdef("setoid","Setoid","The contructor for the type of set with an equivalence relation on it.",new String[] {});
        register_omdef("setoid","make_Setoid","The contructor for the tuples consisting of a set, an equivalence relation on the set, and a proof that the relation is actually an equivalence relation.",new String[] {});
        register_omdef("sigma",null,"Sigma Types for OM Declaration of symbols for types and objects An OpenMath object which uses any of the symbols here defined, has to use them in accordance with the definitions in ESPRIT deliverable 1.3.2b . Initial version: O. Caprotti and H. Elbers (July 2, 1998) Updated: O. Caprotti (March 5, 1999) Updated: O. Caprotti (May 20, 1999) added \\\"mapsto\\\", made a CDGroup",new String[] {});
        register_omdef("sigma","SigmaType","The type constructor of cartesian products. It takes a list of type-attributed variables and an OpenMath object.",new String[] {});
        register_omdef("sigma","Pair","The pairing constructor. It takes two OpenMath objects as first element and second element of the pair, and a third optional OpenMath object that represents the type of this pair.",new String[] {});
        register_omdef("sigma","PairProj1","The first projection function. It satisfies sigma-reduction.",new String[] {});
        register_omdef("sigma","PairProj2","The second projection function. It satisfies sigma-reduction.",new String[] {});
        register_omdef("sts",null,"Definitions of the symbols used by the OpenMath Small Type System.",new String[] {});
        register_omdef("sts","type","A symbol to be used within an OpenMath attribute to specify the type of the object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"sts\" name=\"type\"></OMS> <OMS cd=\"setname1\" name=\"C\"></OMS> </OMATP> <OMV name=\"z\"></OMV> </OMATTR> </OMOBJ>"});
        register_omdef("sts","mapsto","This symbol represents the construction of a function type. The first n-1 children denote the types of the arguments, the last denotes the return type.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> <OMS cd=\"setname1\" name=\"Z\"></OMS> <OMS cd=\"setname1\" name=\"R\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("sts","nary","Constructs a child of mapsto which denotes an arbitrary number of copies of the argument of nary.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMA> <OMS cd=\"sts\" name=\"nary\"></OMS> <OMS cd=\"sts\" name=\"Object\"></OMS> </OMA> <OMS cd=\"sts\" name=\"Object\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("sts","nassoc","Constructs a child of mapsto which denotes an arbitrary number of copies of the argument of nassoc. The operator is associative on these arguments which means that repeated uses may be flattened/unflattened.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMA> <OMS cd=\"sts\" name=\"nassoc\"></OMS> <OMV name=\"AbelianSemiGroup\"></OMV> </OMA> <OMV name=\"AbelianSemiGroup\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("sts","error","The error symbol is the \\\'return type\\\' of error symbols in the error signature file.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMV name=\"OMSymbol\"></OMV> <OMS cd=\"sts\" name=\"error\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("sts","structure","The structure element is used to represent a structure of a particular (algebraic) type.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMA> <OMS cd=\"sts\" name=\"structure\"></OMS> <OMV name=\"set\"></OMV> </OMA> <OMV name=\"set\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("sts","binder","An `OMBIND\\\' object has three parts: a \\\"binder\\\" such as \\\"lambda\\\" or \\\"for all\\\", a (list of) bound variables, and an expression. The use of `binder\\\' in a signature indicates that we are describing something which can only be used as the first child of an OMBIND construct.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMS cd=\"sts\" name=\"binder\"></OMS> </OMOBJ>"});
        register_omdef("sts","attribution","An `attribution\\\' object consists of pairs of keys and values. The use of the symbol `attribution\\\' in a signature indicates that the symbol is to be used as a key.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMS cd=\"sts\" name=\"attribution\"></OMS> </OMOBJ>"});
        register_omdef("sts","Object","Denotes any OpenMath object.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMA> <OMS cd=\"sts\" name=\"nary\"></OMS> <OMS cd=\"sts\" name=\"Object\"></OMS> </OMA> <OMS cd=\"sts\" name=\"Object\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("sts","NumericalValue","Denotes an OpenMath object that is to be thought of as something that represents a numerical value, or a numerical value.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMS cd=\"sts\" name=\"NumericalValue\"></OMS> <OMS cd=\"sts\" name=\"NumericalValue\"></OMS> <OMS cd=\"sts\" name=\"NumericalValue\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("sts","SetNumericalValue","Denotes an OpenMath object that is to be thought of as something that represents a set of numerical values, or a set of numerical values.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"sts\" name=\"mapsto\"></OMS> <OMS cd=\"sts\" name=\"NumericalValue\"></OMS> <OMS cd=\"sts\" name=\"SetNumericalValue\"></OMS> </OMA> </OMOBJ>"});
        register_omdef("transc1",null,"This CD holds the definitions of many transcendental functions. They are defined as in Abromowitz and Stegun (ninth printing on), with precise reductions to logs in the case of inverse functions. Note that, if signed zeros are supported, some strict inequalities have to become weak . It is intended to be `compatible\\\' with the MathML elements denoting trancendental functions. Some additional functions are in the CD transc2.",new String[] {});
        register_omdef("transc1","log","This symbol represents a binary log function; the first argument is the base, to which the second argument is log\\\'ed. It is defined in Abramowitz and Stegun, Handbook of Mathematical Functions, section 4.1",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"transc1\" name=\"log\"></OMS> <OMF dec=\"10\"></OMF> <OMF dec=\"100\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("transc1","ln","This symbol represents the ln function (natural logarithm) as described in Abramowitz and Stegun, section 4.1. It takes one argument. Note the description in the CMP/FMP of the branch cut. If signed zeros are in use, the inequality needs to be non-strict.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"transc1\" name=\"ln\"></OMS> <OMF dec=\"1\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("transc1","exp","This symbol represents the exponentiation function as described in Abramowitz and Stegun, section 4.2. It takes one argument.",new String[] {});
        register_omdef("transc1","sin","This symbol represents the sin function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","cos","This symbol represents the cos function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","tan","This symbol represents the tan function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","sec","This symbol represents the sec function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","csc","This symbol represents the csc function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","cot","This symbol represents the cot function as described in Abramowitz and Stegun, section 4.3. It takes one argument.",new String[] {});
        register_omdef("transc1","sinh","This symbol represents the sinh function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","cosh","This symbol represents the cosh function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","tanh","This symbol represents the tanh function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","sech","This symbol represents the sech function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","csch","This symbol represents the csch function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","coth","This symbol represents the coth function as described in Abramowitz and Stegun, section 4.5. It takes one argument.",new String[] {});
        register_omdef("transc1","arcsin","This symbol represents the arcsin function. This is the inverse of the sin function as described in Abramowitz and Stegun, section 4.4. It takes one argument.",new String[] {});
        register_omdef("transc1","arccos","This symbol represents the arccos function. This is the inverse of the cos function as described in Abramowitz and Stegun, section 4.4. It takes one argument.",new String[] {});
        register_omdef("transc1","arctan","This symbol represents the arctan function. This is the inverse of the tan function as described in Abramowitz and Stegun, section 4.4. It takes one argument.",new String[] {});
        register_omdef("transc1","arcsec","This symbol represents the arcsec function as described in Abramowitz and Stegun, section 4.4.",new String[] {});
        register_omdef("transc1","arccsc","This symbol represents the arccsc function as described in Abramowitz and Stegun, section 4.4.",new String[] {});
        register_omdef("transc1","arccot","This symbol represents the arccot function as described in Abramowitz and Stegun, section 4.4.",new String[] {});
        register_omdef("transc1","arcsinh","This symbol represents the arcsinh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc1","arccosh","This symbol represents the arccosh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc1","arctanh","This symbol represents the arctanh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc1","arcsech","This symbol represents the arcsech function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc1","arccsch","This symbol represents the arccsch function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc1","arccoth","This symbol represents the arccoth function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc2",null,"This CD holds the definition of a two-argument version of arctan, useful for defining the argument of a complex number, and equivalent to Fortran\\\'s ATAN2 function. It also holds a definition of the unwinding number, useful for writing correct relationships between elementary functions.",new String[] {});
        register_omdef("transc2","arctan","This symbol represents the two-argument arctan function as in Fortran\\\'s ATAN2. arctan(x,y) is a value of arctan(y/x). For real x,y arctan(x,y) is positive when y is positive, negative when y is negative. If y is zero, the result is 0 if x is positive, and $\\\\pi$ if x is negative. If x is zero, the result has absolute value $\\\\pi/2$.",new String[] {});
        register_omdef("transc2","unwind","The unwinding number denotes the extent to which $z=\\\\ln\\\\exp z$ is not true. It was orignally defined in Corless,R.M. & Jeffrey,D.J., The Unwinding Number. SIGSAM Bulletin 30(1996) 2, pp. 28-35. However, we take the definition (which has a change of sign) from Corless,R.M., Davenport,J.H., Jeffrey,D.J. & Watt,S.M., According to Abramowitz and Stegun. SIGSAM Bulletin 34(2000) 2, pp. 58--65. Note that the symbol is normally denoted by ${\\\\cal K}$.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"relation1\" name=\"eq\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"arcsin\"></OMS> <OMV name=\"z\"></OMV> </OMA> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"arctan\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"divide\"></OMS> <OMV name=\"z\"></OMV> <OMA> <OMS cd=\"arith1\" name=\"root\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"alg1\" name=\"one\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"power\"></OMS> <OMV name=\"z\"></OMV> <OMI> 2 </OMI> </OMA> </OMA> <OMI> 2 </OMI> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"arith1\" name=\"times\"></OMS> <OMS cd=\"nums1\" name=\"pi\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMA> <OMS cd=\"transc2\" name=\"unwind\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"ln\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"plus\"></OMS> <OMS cd=\"alg1\" name=\"one\"></OMS> <OMV name=\"z\"></OMV> </OMA> </OMA> </OMA> </OMA> <OMA> <OMS cd=\"transc2\" name=\"unwind\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"unary_minus\"></OMS> <OMA> <OMS cd=\"transc1\" name=\"ln\"></OMS> <OMA> <OMS cd=\"arith1\" name=\"minus\"></OMS> <OMS cd=\"alg1\" name=\"one\"></OMS> <OMV name=\"z\"></OMV> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMA> </OMOBJ>"});
        register_omdef("transc3",null,"This CD holds the definitions of many transcendental and related functions. They are defined as multi-valued functions with precise reductions to logs in the case of inverse functions. Note that we use the same names as in the single-valued case, even though it would be traditional to render them with capital letters. In sum <OMS cd=\\\"transc3\\\" name=\\\"ln\\\"/> is multi-valued, while <OMS cd=\\\"transc1\\\" name=\\\"ln\\\"/> is single-valued. Note that in many cases A+S only states the log restrictions under some circumstances: JHD has proved (22.8.2002) all the inverse trig. ones",new String[] {});
        register_omdef("transc3","log","This symbol represents a binary log function; the first argument is the base, to which the second argument is log\\\'ed. It is defined in Abramowitz and Stegun, Handbook of Mathematical Functions, section 4.1",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"transc3\" name=\"log\"></OMS> <OMF dec=\"10\"></OMF> <OMF dec=\"100\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("transc3","ln","This symbol represents the ln function (natural logarithm) as a multivalued function.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMA> <OMS cd=\"transc3\" name=\"ln\"></OMS> <OMF dec=\"1\"></OMF> </OMA> </OMOBJ>"});
        register_omdef("transc3","arcsin","This symbol represents the arcsin function. This is the multi-valued inverse of the sin function as described in Abramowitz and Stegun, section 4.4. It takes one argument.",new String[] {});
        register_omdef("transc3","arccos","This symbol represents the arccos function. This is the multivalued inverse of the cos function.",new String[] {});
        register_omdef("transc3","arctan","This symbol represents the arctan function. This is the multi-valued inverse of the tan function.",new String[] {});
        register_omdef("transc3","arcsec","This symbol represents the multivalued arcsec function as the inverse of sec.",new String[] {});
        register_omdef("transc3","arccsc","This symbol represents the multivalued arccsc function as the inverse of csc.",new String[] {});
        register_omdef("transc3","arccot","This symbol represents the multi-valued arccot function as the inverse of cot",new String[] {});
        register_omdef("transc3","arcsinh","This symbol represents the Arcsinh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc3","arccosh","This symbol represents the Arccosh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc3","arctanh","This symbol represents the Arctanh function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc3","arcsech","This symbol represents the Arcsech function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc3","arccsch","This symbol represents the Arccsch function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("transc3","arccoth","This symbol represents the Arccoth function as described in Abramowitz and Stegun, section 4.6.",new String[] {});
        register_omdef("typesorts",null,"Type Sorts as used in the Calculus of Constructions and in its Extensions. Initial version: O. Caprotti",new String[] {});
        register_omdef("typesorts","Prop","The type of propositions",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMATTR> <OMATP> <OMS cd=\"cc\" name=\"type\"></OMS> <OMS cd=\"typesorts\" name=\"Prop\"></OMS> </OMATP> <OMS cd=\"logic1\" name=\"true\"></OMS> </OMATTR> </OMOBJ>"});
        register_omdef("typesorts","Type0","The type of sets in a hierarchy of types.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"> <OMATTR> <OMATP> <OMS cd=\"ecc\" name=\"type\"></OMS> <OMS cd=\"typesorts\" name=\"Type0\"></OMS> </OMATP> <OMS cd=\"typesorts\" name=\"Prop\"></OMS> </OMATTR> </OMOBJ>"});
        register_omdef("typesorts","Type","The cumulative type of the type of sets in a hierarchy of types.",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMath\" cdbase=\"http://www.openmath.org/cd\" version=\"2.0\"><OMATTR> <OMATP> <OMS cd=\"icc\" name=\"type\"></OMS> <OMS cd=\"typesorts\" name=\"Type\"></OMS> </OMATP> <OMS cd=\"typesorts\" name=\"Type0\"></OMS> </OMATTR> </OMOBJ>"});
        register_omdef("units_imperial1",null,"This CD defines symbols to represent imperial standard measures.",new String[] {});
        register_omdef("units_imperial1","foot","This symbol represents the measure of one foot. This is the standard imperial measure for distance.",new String[] {});
        register_omdef("units_imperial1","yard","This symbol represents the measure of one yard. This is a standard imperial measure for distance, defined in terms of the foot.",new String[] {});
        register_omdef("units_imperial1","mile","This symbol represents the measure of one (land, or statute) mile. This is a standard imperial measure for distance, defined in terms of the foot.",new String[] {});
        register_omdef("units_imperial1","acre","This symbol represents the measure of one acre. This is a standard imperial measure for area.",new String[] {});
        register_omdef("units_imperial1","pint","This symbol represents the measure of one (imperial) pint. This is the standard imperial measure for volume. See units_us1 for the U.S. pint.",new String[] {});
        register_omdef("units_imperial1","miles_per_hr","This symbol represents the measure of one mile per hour. This is a standard imperial measure for speed.",new String[] {});
        register_omdef("units_imperial1","miles_per_hr_sqrd","This symbol represents the measure of one mile per hour squared. This is a standard imperial measure for acceleration.",new String[] {});
        register_omdef("units_imperial1","pound_mass","This symbol represents the measure of the mass which weighs one pound under the influence of standard gravity.",new String[] {});
        register_omdef("units_imperial1","pound_force","This symbol represents the measure of force of one pound.",new String[] {});
        register_omdef("units_imperial1","degree_Fahrenheit","This symbol represents the measure of one degree Fahrenheit. This is the standard imperial measure for temperature.",new String[] {});
        register_omdef("units_imperial1","bar","This symbol represents the measure of one bar. This is the standard imperial measure for pressure.",new String[] {});
        register_omdef("units_metric1",null,"This CD defines symbols to represent the basic physical units in the SI (syst\\\\\\\'eme international) system of units. It should probably be renamed units_si.",new String[] {});
        register_omdef("units_metric1","metre","This symbol represents the measure of one metre. This is the standard SI unit measure for physical distance.",new String[] {});
        register_omdef("units_metric1","metre_sqrd","This symbol represents the measure of one metre squared. This is the standard SI measure for physical area.",new String[] {});
        register_omdef("units_metric1","litre","This symbol represents the measure of one litre. This is a standard metric measure for physical volume.",new String[] {});
        register_omdef("units_metric1","litre_pre1964","This symbol represents the previous (1901-1964) measure of one litre. This used to be a standard metric measure for physical volume.",new String[] {});
        register_omdef("units_metric1","metres_per_second","This symbol represents the measure of one metre per second. This is the standard SI measure for speed.",new String[] {});
        register_omdef("units_metric1","metres_per_second_sqrd","This symbol represents the measure of one metre per second squared. This is the standard SI measure for acceleration.",new String[] {});
        register_omdef("units_metric1","second","This symbol represents the measure of one second. This is the standard SI measure for time.",new String[] {});
        register_omdef("units_metric1","gramme","This symbol represents the measure of one gramme. This is not quite the standard SI measure for mass, which is the kilogramme, but OpenMath chooses to regard the gramme as standard, otherwise one would have to call it the milli-kilogramme.",new String[] {});
        register_omdef("units_metric1","Newton","This symbol represents the measure of one Newton. This is the standard SI measure for force.",new String[] {});
        register_omdef("units_metric1","Joule","This symbol represents the measure of one Joule. This is the standard SI measure for energy.",new String[] {});
        register_omdef("units_metric1","Watt","This symbol represents the measure of one Watt. This is the standard SI measure for power.",new String[] {});
        register_omdef("units_metric1","degree_Kelvin","This symbol represents the measure of one degree Kelvin. This is a standard SI measure for temperature relative to absolute zero.",new String[] {});
        register_omdef("units_metric1","degree_Celsius","This symbol represents the measure of one degree Celsius. This is a standard metric measure for temperature.",new String[] {});
        register_omdef("units_metric1","Pascal","This symbol represents the measure of one Newton per square metre. This is the standard SI measure for pressure.",new String[] {});
        register_omdef("units_metric1","Newton_per_sqr_metre","This symbol represents the measure of one Newton per square metre. This is another (deprecated in OpenMath) name for the standard SI measure for pressure, the Pascal.",new String[] {});
        register_omdef("units_metric1","Coulomb","This symbol represents the measure of one Coulomb. This is the standard SI measure for charge.",new String[] {});
        register_omdef("units_metric1","amp","This symbol represents the measure of one amp. This is the standard SI measure for current.",new String[] {});
        register_omdef("units_metric1","volt","This symbol represents the measure of one volt. This is the standard SI measure for voltage.",new String[] {});
        register_omdef("units_ops1",null,"This CD defines various symbols for use in the manipulation of units.",new String[] {});
        register_omdef("units_ops1","prefix","This symbol represents the fact that the second argument (a unit) has been effectively multiplied by a constant specified by the first argument (a prefix).",new String[] {"<OMOBJ xmlns=\"http://www.openmath.org/OpenMathCD\"> <OMA> <OMS cd=\"units_ops1\" name=\"prefix\"></OMS> <OMS cd=\"units_siprefix1\" name=\"kilo\"></OMS> <OMV name=\"unit\"></OMV> </OMA> </OMOBJ>"});
        register_omdef("units_siprefix1",null,"This CD defines symbols for the SI prefixes to indicate multiplication by a power of 10.",new String[] {});
        register_omdef("units_siprefix1","yotta","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^24$",new String[] {});
        register_omdef("units_siprefix1","zetta","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^21$",new String[] {});
        register_omdef("units_siprefix1","exa","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^18$",new String[] {});
        register_omdef("units_siprefix1","peta","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^15$",new String[] {});
        register_omdef("units_siprefix1","tera","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^12$",new String[] {});
        register_omdef("units_siprefix1","giga","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^9$",new String[] {});
        register_omdef("units_siprefix1","mega","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^6$",new String[] {});
        register_omdef("units_siprefix1","kilo","This symbol represents the fact that the subsequent unit has been effectively multiplied by $1000$",new String[] {});
        register_omdef("units_siprefix1","hecto","This symbol represents the fact that the subsequent unit has been effectively multiplied by $100$",new String[] {});
        register_omdef("units_siprefix1","deka","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10$",new String[] {});
        register_omdef("units_siprefix1","deci","This symbol represents the fact that the subsequent unit has been effectively multiplied by $0.1$",new String[] {});
        register_omdef("units_siprefix1","centi","This symbol represents the fact that the subsequent unit has been effectively multiplied by $0.01$",new String[] {});
        register_omdef("units_siprefix1","milli","This symbol represents the fact that the subsequent unit has been effectively multiplied by $0.001$",new String[] {});
        register_omdef("units_siprefix1","micro","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-6$",new String[] {});
        register_omdef("units_siprefix1","nano","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-9$",new String[] {});
        register_omdef("units_siprefix1","pico","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-12$",new String[] {});
        register_omdef("units_siprefix1","femto","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-15$",new String[] {});
        register_omdef("units_siprefix1","atto","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-18$",new String[] {});
        register_omdef("units_siprefix1","zepto","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-21$",new String[] {});
        register_omdef("units_siprefix1","yocto","This symbol represents the fact that the subsequent unit has been effectively multiplied by $10^-24$",new String[] {});
        register_omdef("units_sts",null,"This CD holds the units and dimension symbols used by the OpenMath Small Type System, when handling units and dimensions.",new String[] {});
        register_omdef("units_sts","unit_prefix","The type of all unit prefixes, such as \\\"kilo\\\".",new String[] {});
        register_omdef("units_time1",null,"This CD defines symbols to represent the basic physical units of time in the SI (syst\\\\\\\'eme international) system of units. and therefore most other modern systems such as \\\"Imperial\\\" and \\\"U.S.\\\".",new String[] {});
        register_omdef("units_time1","second","This symbol represents the measure of one second of time. This is the standard SI unit measure for time.",new String[] {});
        register_omdef("units_time1","minute","This symbol represents the measure of one minute of time.",new String[] {});
        register_omdef("units_time1","hour","This symbol represents the measure of one hour of time.",new String[] {});
        register_omdef("units_time1","day","This symbol represents the measure of one day of time. The definitions below ignore the possibilities of \\\"leap seconds\\\".",new String[] {});
        register_omdef("units_time1","week","This symbol represents the measure of one week of time.",new String[] {});
        register_omdef("units_time1","calendar_month","This symbol represents the measure of one month of (calendar) time.",new String[] {});
        register_omdef("units_time1","calendar_year","This symbol represents the measure of one year of (calendar) time.",new String[] {});
        register_omdef("units_us1",null,"This CD defines symbols to represent U.S. customary unit measures.",new String[] {});
        register_omdef("units_us1","foot_us_survey","This symbol represents the measure of one U.S. Survey foot.",new String[] {});
        register_omdef("units_us1","yard_us_survey","This symbol represents the measure of one U.S. Survey yard.",new String[] {});
        register_omdef("units_us1","mile_us_survey","This symbol represents the measure of one U.S. Survey mile.",new String[] {});
        register_omdef("units_us1","acre_us_survey","This symbol represents the measure of one U.S. Survey acre.",new String[] {});
        register_omdef("units_us1","pint_us_dry","This symbol represents the measure of one U.S. dry pint.",new String[] {});
        register_omdef("units_us1","pint_us_liquid","This symbol represents the measure of one U.S. liquid pint.",new String[] {});
        register_omdef("veccalc1",null,"This CD contains symbols to represent functions which are concerned with vector calculus.",new String[] {});
        register_omdef("veccalc1","divergence","This symbol is used to represent the divergence function. It takes one argument which should be a vector of scalar valued functions, intended to represent a vector valued function and returns a scalar value. It should satisfy the defining relation: divergence(F) = \\\\partial(F_(x_1))/\\\\partial(x_1) + ... + \\\\partial(F_(x_n))/\\\\partial(x_n)",new String[] {});
        register_omdef("veccalc1","grad","This symbol is used to represent the grad function. It takes one argument which should be a scalar valued function and returns a vector of functions. It should satisfy the defining relation: grad(F) = (\\\\partial(F)/\\\\partial(x_1), ... ,\\\\partial(F)/partial(x_n))",new String[] {});
        register_omdef("veccalc1","curl","This symbol is used to represent the curl function. It takes one argument which should be a vector of scalar valued functions, intended to represent a vector valued function and returns a vector of functions. It should satisfy the defining relation: curl(F) = i X \\\\partial(F)/\\\\partial(x) + j X \\\\partial(F)/\\\\partial(y) + j X \\\\partial(F)/\\\\partial(Z) where i,j,k are the unit vectors corresponding to the x,y,z axes respectively and the multiplication X is cross multiplication.",new String[] {});
        register_omdef("veccalc1","Laplacian","This symbol is used to represent the laplacian function. It takes one argument which should be a vector of scalar valued functions, intended to represent a vector valued function and returns a vector of functions. It should satisfy the defining relation: laplacian(F) = \\\\partial^2(F)/\\\\partial(x_1)^2 + ... + \\\\partial^2(F)/\\\\partial(x_n)^2",new String[] {});
    }

    static { init(); }

}
